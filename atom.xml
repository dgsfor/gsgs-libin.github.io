<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>猿的野生香蕉</title>
  
  <subtitle>野生</subtitle>
  <link href="https://blog.itmonkey.icu/atom.xml" rel="self"/>
  
  <link href="https://blog.itmonkey.icu/"/>
  <updated>2022-03-03T02:04:11.664Z</updated>
  <id>https://blog.itmonkey.icu/</id>
  
  <author>
    <name>野生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>耗时4个月，精心给自己做了一顿饭</title>
    <link href="https://blog.itmonkey.icu/2022/03/03/make-a-meal-in-4-months/"/>
    <id>https://blog.itmonkey.icu/2022/03/03/make-a-meal-in-4-months/</id>
    <published>2022-03-03T01:24:55.000Z</published>
    <updated>2022-03-03T02:04:11.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有一天不想出去买菜，但是又想吃饭，怎么办？看着阳台上养的不好看的花，下定决心，拔掉，改种菜。<br><img src="/img/make-a-meal-in-4-months/1.png" alt="jpg"></p><h2 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h2><h3 id="购买种子"><a href="#购买种子" class="headerlink" title="购买种子"></a>购买种子</h3><p>万能的淘宝，买了一堆种子，活哪个吃那个。</p><p><img src="/img/make-a-meal-in-4-months/2.jpg" alt="jpg2"></p><h3 id="换地方"><a href="#换地方" class="headerlink" title="换地方"></a>换地方</h3><p>阳台小盆子太小了，肯定不够，换成大的。万能的淘宝，又买了一些盆子。</p><p><img src="/img/make-a-meal-in-4-months/3.jpg" alt="jpg3"></p><h3 id="种上种子"><a href="#种上种子" class="headerlink" title="种上种子"></a>种上种子</h3><p>缺少一点土，趁着夜黑风高，戴着帽子去楼下挖了点土。<br>回来种上自己喜欢的菜，就是这个样子了。<br>备注：由于是冬天，怕我的种子活不过这个冬天，象征性的用保鲜膜当大棚，还挺像一回事。</p><p><img src="/img/make-a-meal-in-4-months/4.jpg" alt="jpg4"></p><h3 id="精心洒水"><a href="#精心洒水" class="headerlink" title="精心洒水"></a>精心洒水</h3><p>为了更好的让我的种子茁壮成长，买了一个喷壶(还挺好玩，第一天就玩了一个小时)。</p><p><img src="/img/make-a-meal-in-4-months/5.jpg" alt="jpg5"></p><h3 id="思念"><a href="#思念" class="headerlink" title="思念"></a>思念</h3><p>上班的时候，为了能在办公室也能看到我的种子、看到我的菜。<br>没错，我在办公室种起了葱，看着他，就仿佛看到了家里的菜。</p><p><img src="/img/make-a-meal-in-4-months/6.jpg" alt="jpg6"></p><h3 id="喜悦-发芽了"><a href="#喜悦-发芽了" class="headerlink" title="喜悦(发芽了)"></a>喜悦(发芽了)</h3><p>慢慢的，他发了芽，办公室的葱也发了芽，于是乎我更认真地浇水了。</p><p><img src="/img/make-a-meal-in-4-months/7.jpg" alt="jpg7"></p><p><img src="/img/make-a-meal-in-4-months/8.jpg" alt="jpg8"></p><h3 id="春天来了"><a href="#春天来了" class="headerlink" title="春天来了"></a>春天来了</h3><p>终于春天来了，万物复苏，我的菜似乎可以吃了，办公室的葱仿佛也有了能下锅的样子。</p><p><img src="/img/make-a-meal-in-4-months/9.jpg" alt="jpg9"></p><p><img src="/img/make-a-meal-in-4-months/10.jpg" alt="jpg10"></p><h3 id="晴天霹雳"><a href="#晴天霹雳" class="headerlink" title="晴天霹雳"></a>晴天霹雳</h3><p>有一天回去，发现菜长虫子了，怎么办？</p><h3 id="采摘"><a href="#采摘" class="headerlink" title="采摘"></a>采摘</h3><p>为了跟虫子抢菜吃，不让他给我吃完了，我提前在我的菜园里采摘了如下菜品：<code>虾仁</code>、<code>蒜薹</code>、<code>西蓝花</code>、<code>贵州腊肉</code>、<code>菠菜叶</code>。<br><img src="/img/make-a-meal-in-4-months/11.jpg" alt="jpg11"></p><h3 id="下厨"><a href="#下厨" class="headerlink" title="下厨"></a>下厨</h3><p>经过了半个小时的烹饪，给自己做了两荤一素，饱餐一顿。</p><p><img src="/img/make-a-meal-in-4-months/12.jpg" alt="jpg12"></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>真是美味，完美的2022开端。</p>]]></content>
    
    
    <summary type="html">用了四个月的时间，我给自己做了一顿饭</summary>
    
    
    
    <category term="日常生活" scheme="https://blog.itmonkey.icu/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="日常" scheme="https://blog.itmonkey.icu/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="烹饪" scheme="https://blog.itmonkey.icu/tags/%E7%83%B9%E9%A5%AA/"/>
    
  </entry>
  
  <entry>
    <title>利用树莓派做一个&quot;私人助理&quot;</title>
    <link href="https://blog.itmonkey.icu/2022/03/01/create-personal-assistant-use-raspberry-pi/"/>
    <id>https://blog.itmonkey.icu/2022/03/01/create-personal-assistant-use-raspberry-pi/</id>
    <published>2022-03-01T08:51:23.000Z</published>
    <updated>2022-03-01T09:43:24.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近老是记不住一些事情，写到备忘录有时候忘记看手机也白扯。想着是否用一些更明显的”提醒动作”来告知自己要做什么了。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>“明显的提醒动作”，在工位上的话，无非就是闪烁的灯光+刺耳的声音。那么满足这个的，树莓派就非常合适，顺便把尘封已久的技能拿出来擦亮一波。<br>那么有了这个方向，简单规划一下：</p><ul><li>利用树莓派做基础环境支撑</li><li>利用<code>rgb led hat</code>做灯光提醒展示</li><li>利用3.5mm小喇叭做音频输出</li><li>写点python脚本</li></ul><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>先展示一波成果吧，编写的程序中，rgd led阵列灯可以展示多种图形，从而来区分到底我该干什么事情了。</p><ul><li>比如这个笑脸，就是代表早上站会要开始了</li></ul><p><img src="/img/create-personal-assistant-use-raspberry-pi/1.jpg" alt="png1"></p><ul><li>比如这个感叹号，就代表要写运营报告了</li></ul><p><img src="/img/create-personal-assistant-use-raspberry-pi/2.jpg" alt="png2"></p><ul><li>等等</li></ul><p>还有很多模型，也可以自己写一些模型，不过8x8的阵列限制比较多，所以没啥特别好看的。除非你买一些其他的显示屏接上。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先我们做这个之前，简单规划一下步骤：</p><ul><li>给树莓派刷好系统</li><li>外接一个rgb led hat</li><li>外接一个3.5mm小喇叭</li><li>编写程序</li><li>增加定时任务</li></ul><h3 id="给树莓派刷好系统"><a href="#给树莓派刷好系统" class="headerlink" title="给树莓派刷好系统"></a>给树莓派刷好系统</h3><p>这个不说了，我的就是一个树莓派4B，网上刷机教程多的不行，不浪费时间写这玩意了。</p><h3 id="外接一个rgb-led-hat"><a href="#外接一个rgb-led-hat" class="headerlink" title="外接一个rgb led hat"></a>外接一个rgb led hat</h3><p>买了一个<code>rgb led hat</code>，本来想买一个<code>sense hat</code>，最后想想其实用不到这么多功能和额外的传感器，干脆买一个最简单的led阵列就好了。<br>我直接买的就是支持gpio的hat，所以直接对接起来就好，非常简单。如下图：<br><img src="/img/create-personal-assistant-use-raspberry-pi/3.jpg" alt="png3"></p><p><img src="/img/create-personal-assistant-use-raspberry-pi/4.jpg" alt="png4"></p><p>最终我们给树莓派插上电，连接上网络大概就这样吧：</p><p><img src="/img/create-personal-assistant-use-raspberry-pi/5.jpg" alt="png5"></p><h3 id="外接一个3-5mm小喇叭"><a href="#外接一个3-5mm小喇叭" class="headerlink" title="外接一个3.5mm小喇叭"></a>外接一个3.5mm小喇叭</h3><p>对于播放声音，3.5mm的耳机音响，最合适不过了。不用额外的配置，插上就能用。</p><p><img src="/img/create-personal-assistant-use-raspberry-pi/6.jpg" alt="png6"></p><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>首先确认一下需求：</p><ul><li>支持展示不同模型(图案)</li><li>支持控制显示的时长、频率等</li><li>支持自定义提醒声音</li><li>支持增加定时任务</li></ul><p>有了上面的内容，我写了代码，没啥难度，就是一些简单的逻辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/gsgs-libin/raspberrypi-remind</span><br></pre></td></tr></table></figure><h4 id="手动运行"><a href="#手动运行" class="headerlink" title="手动运行"></a>手动运行</h4><p>可以先看一下他的运行帮助:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(remind) root@raspberrypi:/www/remind<span class="comment"># python remind_index.py -h</span></span><br><span class="line">test.py -t &lt;taskName&gt; -m &lt;modelName&gt; -v &lt;voice&gt;</span><br><span class="line"></span><br><span class="line">-t 指定任务名称</span><br><span class="line">-m 指定模型名称</span><br><span class="line">-v 是否输出声音</span><br></pre></td></tr></table></figure><p>那么开始运行吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(remind) root@raspberrypi:/www/remind<span class="comment"># python remind_index.py -t output_weekly_report -m exclamation -v false</span></span><br><span class="line">use task: output_weekly_report</span><br><span class="line">use model: exclamation</span><br><span class="line">voice status: <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p><img src="/img/create-personal-assistant-use-raspberry-pi/7.jpg" alt="png7"><br><img src="/img/create-personal-assistant-use-raspberry-pi/8.jpg" alt="png8"><br><img src="/img/create-personal-assistant-use-raspberry-pi/9.jpg" alt="png9"></p><h4 id="声音提醒"><a href="#声音提醒" class="headerlink" title="声音提醒"></a>声音提醒</h4><p>这个需要接入百度的api，然后个人申请的有调用限制，我白嫖了一个无限制的，放到github上了，想要用的可以直接用。</p><p>另外这个可以有<code>妹子音</code>，还是非常不错哦!</p><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>利用crontab，增加自己一系列提醒事项，举个简单例子吧</p><p>每天早上10点提醒我写日报：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 10 * * * root python remind_index.py -t output_weekly_report -m smile -v false</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">利用树莓派做一个提醒器</summary>
    
    
    
    <category term="运维进阶" scheme="https://blog.itmonkey.icu/categories/%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="raspberry-pi" scheme="https://blog.itmonkey.icu/tags/raspberry-pi/"/>
    
  </entry>
  
  <entry>
    <title>自建mysql监控方案</title>
    <link href="https://blog.itmonkey.icu/2022/01/21/mysql-prometheus-exporter/"/>
    <id>https://blog.itmonkey.icu/2022/01/21/mysql-prometheus-exporter/</id>
    <published>2022-01-21T05:43:50.000Z</published>
    <updated>2022-01-21T06:45:34.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>下载并安装构建</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s https://api.github.com/repos/prometheus/mysqld_exporter/releases/latest   | grep browser_download_url | grep linux-amd64 |  cut -d <span class="string">'"'</span> -f 4 | wget -qi -</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xvf *******</span></span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./mysqld_exporter --version</span></span><br><span class="line">mysqld_exporter, version 0.13.0 (branch: HEAD, revision: ad2847c7fa67b9debafccd5a08bacb12fc9031f1)</span><br><span class="line">  build user:       root@e2043849cb1f</span><br><span class="line">  build date:       20210531-07:30:16</span><br><span class="line">  go version:       go1.16.4</span><br><span class="line">  platform:         linux/amd64</span><br></pre></td></tr></table></figure><ul><li>增加mysql配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> groupadd --system prometheus</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> useradd -s /sbin/nologin --system -g prometheus prometheus</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/.mysqld_exporter.cnf</span></span><br><span class="line">[client]</span><br><span class="line">user=exporter</span><br><span class="line">password=*******</span><br><span class="line"><span class="meta">$</span><span class="bash"> chown root:prometheus /etc/.mysqld_exporter.cnf</span></span><br></pre></td></tr></table></figure><ul><li>修改mysql关于prometheus权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER 'exporter'@'localhost' IDENTIFIED BY 'XXXXXXXX' WITH MAX_USER_CONNECTIONS 3;</span><br><span class="line">GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'localhost';</span><br></pre></td></tr></table></figure><ul><li>增加启动脚本(内容自己调整)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/systemd/system/mysql_exporter.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Prometheus MySQL Exporter</span><br><span class="line">After=network.target</span><br><span class="line">User=prometheus</span><br><span class="line">Group=prometheus</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/www/monitor/mysqld_exporter/mysqld_exporter-0.13.0.linux-amd64/mysqld_exporter \</span><br><span class="line">--config.my-cnf /etc/.mysqld_exporter.cnf \</span><br><span class="line">--collect.global_status \</span><br><span class="line">--collect.info_schema.innodb_metrics \</span><br><span class="line">--collect.auto_increment.columns \</span><br><span class="line">--collect.info_schema.processlist \</span><br><span class="line">--collect.binlog_size \</span><br><span class="line">--collect.info_schema.tablestats \</span><br><span class="line">--collect.global_variables \</span><br><span class="line">--collect.info_schema.query_response_time \</span><br><span class="line">--collect.info_schema.userstats \</span><br><span class="line">--collect.info_schema.tables \</span><br><span class="line">--collect.perf_schema.tablelocks \</span><br><span class="line">--collect.perf_schema.file_events \</span><br><span class="line">--collect.perf_schema.eventswaits \</span><br><span class="line">--collect.perf_schema.indexiowaits \</span><br><span class="line">--collect.perf_schema.tableiowaits \</span><br><span class="line">--collect.slave_status \</span><br><span class="line">--web.listen-address=0.0.0.0:9104</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> mysql_exporter</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl start mysql_exporter</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status mysql_exporter</span></span><br></pre></td></tr></table></figure><ul><li><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:9104/metrics</span></span><br></pre></td></tr></table></figure><p>配置prometheus job</p></li></ul><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- job_name: 'my_mysql_exporter'</span><br><span class="line">  scrape_interval: 60s</span><br><span class="line">  scrape_timeout: 60s</span><br><span class="line">  metrics_path: '/metrics'</span><br><span class="line">  scheme: http</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets:</span><br><span class="line">    - '172.16.5.89:9104'</span><br><span class="line">    labels:</span><br><span class="line">      instance: 'my_mysql'</span><br></pre></td></tr></table></figure><h2 id="配置grafana"><a href="#配置grafana" class="headerlink" title="配置grafana"></a>配置grafana</h2><p>导入grafana之后，效果如下：</p><p><img src="/img/mysql-prometheus-exporter/1.png" alt="png1"></p>]]></content>
    
    
    <summary type="html">使用mysql exporter监控mysql</summary>
    
    
    
    <category term="基础运维" scheme="https://blog.itmonkey.icu/categories/%E5%9F%BA%E7%A1%80%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="prometheus" scheme="https://blog.itmonkey.icu/tags/prometheus/"/>
    
    <category term="mysql" scheme="https://blog.itmonkey.icu/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>自建redis监控方案</title>
    <link href="https://blog.itmonkey.icu/2022/01/21/redis-prometheus-exporter/"/>
    <id>https://blog.itmonkey.icu/2022/01/21/redis-prometheus-exporter/</id>
    <published>2022-01-21T05:43:40.000Z</published>
    <updated>2022-01-21T06:20:51.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>下载并安装构建</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/oliver006/redis_exporter.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis_exporter/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go build .</span></span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis_exporter --version</span></span><br><span class="line">INFO[0000] Redis Metrics Exporter &lt;&lt;&lt; filled in by build &gt;&gt;&gt;    build date: &lt;&lt;&lt; filled in by build &gt;&gt;&gt;    sha1: &lt;&lt;&lt; filled in by build &gt;&gt;&gt;    Go: go1.13.8    GOOS: linux    GOARCH: amd64</span><br></pre></td></tr></table></figure><ul><li>增加启动脚本(内容自己调整)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/systemd/system/redis_exporter.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=redis_exporter</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/www/monitor/redis_exporter/redis_exporter  -redis.addr 127.0.0.1:6379  -redis.password ****** -web.listen-address 0.0.0.0:9121</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> redis_exporter.service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl start redis_exporter.service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status redis_exporter.service</span></span><br></pre></td></tr></table></figure><ul><li><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:9121/metrics</span></span><br></pre></td></tr></table></figure><p>配置prometheus job</p></li></ul><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- job_name: 'my_redis_exporter'</span><br><span class="line">  scrape_interval: 60s</span><br><span class="line">  scrape_timeout: 60s</span><br><span class="line">  metrics_path: '/metrics'</span><br><span class="line">  scheme: http</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets:</span><br><span class="line">    - '172.16.5.89:9121'</span><br><span class="line">    labels:</span><br><span class="line">      instance: 'my_redis'</span><br></pre></td></tr></table></figure><h2 id="配置grafana"><a href="#配置grafana" class="headerlink" title="配置grafana"></a>配置grafana</h2><p>直接用这个dashboard：<a href="https://grafana.com/grafana/dashboards/763" target="_blank" rel="noopener">点击我跳转</a></p><p>导入grafana之后，效果如下：</p><p><img src="/img/redis-prometheus-exporter/1.png" alt="png1"></p>]]></content>
    
    
    <summary type="html">使用redis exporter监控redis</summary>
    
    
    
    <category term="基础运维" scheme="https://blog.itmonkey.icu/categories/%E5%9F%BA%E7%A1%80%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="prometheus" scheme="https://blog.itmonkey.icu/tags/prometheus/"/>
    
    <category term="redis" scheme="https://blog.itmonkey.icu/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>记一次迁移到istio gateway后502问题排查</title>
    <link href="https://blog.itmonkey.icu/2021/12/08/istio-gateway-502/"/>
    <id>https://blog.itmonkey.icu/2021/12/08/istio-gateway-502/</id>
    <published>2021-12-08T02:28:03.000Z</published>
    <updated>2021-12-13T07:50:17.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们目前架构从ingress-controller迁移到istio-gateway后，出现了两次服务出现502的情况。</p><ul><li>A服务调用B服务，出现502</li><li>三方服务回调我方域名，出现502</li></ul><h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><ul><li>场景1<br>AB服务在同一个k8s集群，架构是nginx+php，A服务配置了proxy_pass到B服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /api/ &#123;</span><br><span class="line">    proxy_pass https://api.dgsfor.com/;</span><br><span class="line">    proxy_set_header Host "api.dgsfor.com";</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>场景2<br>三方服务(可以认为是百度等平台)回调我方C服务，三方服务反映结果502</li></ul><h2 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h2><p>正常502，我们都会优先怀疑到服务端是不是有问题，比如最大进程数、request_timeout、数据库、进程挂了等等。<br>所以我们优先看日志。</p><p>假设我方服务是：<code>https://api.dgsfor.com/v1/callback</code>.</p><h2 id="场景1排查"><a href="#场景1排查" class="headerlink" title="场景1排查"></a>场景1排查</h2><ol><li>查看B服务nginx 日志，发现异常</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021/12/01 11:19:37 [error] 44#0: *255 peer closed connection in SSL handshake (104: Connection reset by peer) while SSL handshaking to</span><br><span class="line"> upstream, client: 10.18.33.71, server: api.dgsfor.com, request: "GET /api/ HTTP/1.1", upstream: "https://x.x.x.x:443/",</span><br><span class="line">host: "api.dgsfor.com"</span><br></pre></td></tr></table></figure><ol start="2"><li>可以判断是证书错误，手动curl测试了一下发现正常</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -vvv "https://api.dgsfor.com/v1/callback"</span><br></pre></td></tr></table></figure><ol start="3"><li>初步判断是SNI有问题，直接抓包看看</li></ol><p>抓包结果发现 HelloClient 没有 SNI Extension，因此 gateway RST 连接，直接导致502</p><ol start="4"><li>开启sni extension</li></ol><p>nginx+php模式，需要配置<code>proxy_ssl_server_name on;</code>，才会SNI 扩展。</p><ol start="5"><li>开启后正常</li></ol><h2 id="场景2排查"><a href="#场景2排查" class="headerlink" title="场景2排查"></a>场景2排查</h2><p>有了场景1的思路，我们优先怀疑是不是sni的问题，所以直接把三方回调地址改成http，发现直接可行了，那么没跑了，又是sni的异常。</p><ol><li>ingress-controller可以，istio-gateway不可以</li></ol><p>为什么之前使用ingress没有这个问题，istio-gateway不可以</p><ol start="2"><li>抓包看看吧，先抓使用ingress时候的包</li></ol><p>看Server Hello，发现是有一个默认的sni，是ingress下发的。</p><p><img src="/img/istio-gateway-502/1.png" alt="png1"></p><ol start="3"><li>抓包看看吧，继续抓使用istio-gateway时候的包</li></ol><p>最终结果是没有抓到，在helloClient就rst了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述可以得到的结论是，</p><ul><li><p>ingress-controller在客户端没有配置sni的情况下，会下发一个默认的sni，istio-gateway没有默认下发。<br><img src="/img/istio-gateway-502/2.png" alt="png2"></p></li><li><p>建议调用方都主动配置sni</p></li></ul>]]></content>
    
    
    <summary type="html">业务从ingress迁移到istio出现502情况</summary>
    
    
    
    <category term="k8s" scheme="https://blog.itmonkey.icu/categories/k8s/"/>
    
    
    <category term="ingress" scheme="https://blog.itmonkey.icu/tags/ingress/"/>
    
    <category term="istio" scheme="https://blog.itmonkey.icu/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>istio gateway在GCP上的最佳实践</title>
    <link href="https://blog.itmonkey.icu/2021/11/17/istio-in-gcp/"/>
    <id>https://blog.itmonkey.icu/2021/11/17/istio-in-gcp/</id>
    <published>2021-11-17T05:48:02.000Z</published>
    <updated>2021-11-19T06:31:44.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>没啥背景，就是想折腾，后续慢慢更新，这次先使用istio中的gateway相关。</p><h2 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h2><p>我目前选择helm安装istio相关组件，首先你需要准备好一些东西：</p><ul><li>下载好istio安装包</li><li>helm版本在3以上</li></ul><p>官方文档在这里，可以瞧一瞧：<a href="https://istio.io/latest/docs/setup/install/helm/" target="_blank" rel="noopener">点击我</a></p><blockquote><p>额外说明</p></blockquote><p>我们目前暂时只是用到istio的gateway，至于流量管理，这一块我们后续再研究、再开启(注入sidecar)。<br>所以我们目前就只部署istiod和ingress。</p><h4 id="下载istio配置istioctl"><a href="#下载istio配置istioctl" class="headerlink" title="下载istio配置istioctl"></a>下载istio配置istioctl</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl -L https://istio.io/downloadIstio | sh -</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> istio-1.11.4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把./istio-1.11.4/bin加到你的环境变量里</span></span><br></pre></td></tr></table></figure><h4 id="验证istioctl"><a href="#验证istioctl" class="headerlink" title="验证istioctl"></a>验证istioctl</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> istioctl version</span></span><br><span class="line">no running Istio pods in "istio-system"</span><br><span class="line">1.11.4</span><br></pre></td></tr></table></figure><h4 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h4><p>我们使用helm部署，所有的chart都在<code>manifests/charts</code>里面，可以进去看看。</p><ul><li>创建ns</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl create namespace istio-system</span></span><br></pre></td></tr></table></figure><ul><li>部署istio-base</li></ul><p>这一步做了哪些工作呢？<br>答：Installs Istio cluster resources: CRDs, cluster bindings and associated service accounts.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm install istio-base manifests/charts/base -n istio-system</span></span><br></pre></td></tr></table></figure><ul><li>部署istio-discovery</li></ul><p>这一步做了哪些工作呢？<br>答：Installs istiod service.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm install istiod manifests/charts/istio-control/istio-discovery -n istio-system</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认istiod配置了2G的内存，测试的话可以配置少一点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get all -n istio-system</span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/istiod-576c699795-4fq4f   1/1     Running   0          76s</span><br><span class="line"></span><br><span class="line">NAME             TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                                 AGE</span><br><span class="line">service/istiod   ClusterIP   10.101.203.193   &lt;none&gt;        15010/TCP,15012/TCP,443/TCP,15014/TCP   76s</span><br><span class="line"></span><br><span class="line">NAME                     READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/istiod   1/1     1            1           76s</span><br><span class="line"></span><br><span class="line">NAME                                DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/istiod-576c699795   1         1         1       76s</span><br><span class="line"></span><br><span class="line">NAME                                         REFERENCE           TARGETS         MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">horizontalpodautoscaler.autoscaling/istiod   Deployment/istiod   &lt;unknown&gt;/80%   1         5         1          76s</span><br></pre></td></tr></table></figure><p>如果你想配置nodeSelector，原生的chart虽然有这个配置，但是是不生效的，所以我们需要修改如下：<br>具体可以看我提的这个issues：<code>https://github.com/istio/istio/issues/36110</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim manifests/charts/istio-control/istio-discovery/templates/deployment.yaml</span></span><br><span class="line">添加</span><br><span class="line">    spec:</span><br><span class="line">      &#123;&#123;- if .Values.pilot.nodeSelector &#125;&#125;</span><br><span class="line">      nodeSelector: &#123;&#123; toYaml .Values.pilot.nodeSelector | nindent 8 &#125;&#125;</span><br><span class="line">      &#123;&#123;- end &#125;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后我们再去values.yaml中设置我们想要的nodeselector</span></span><br><span class="line">  nodeSelector:</span><br><span class="line">    nodetype: istio-gateway</span><br></pre></td></tr></table></figure><ul><li>部署istio-ingress</li></ul><p>这一步做了哪些工作呢？<br>答：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.修改配置，gateways.type: 从LoadBalancer修改成NodePort</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.修改配置，gateways.autoscaleEnabled：关闭hpa</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.修改配置，从deployment部署方式调整成dasmonset方式，由于官方chart没有这样的支持，我单独fork了一个仓库做修改，有兴趣可以看看。</span></span><br></pre></td></tr></table></figure><p>仓库地址：<code>https://github.com/gsgs-libin/istio-charts</code></p><p>部署过程中遇到的问题，提了一个issue，具体可以看这里：<code>https://github.com/istio/istio/issues/36128</code></p><p>开始部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install istio-ingress manifests/charts/gateways/istio-ingress -n istio-system</span><br></pre></td></tr></table></figure><h2 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h2><p>由于我们只用了gateway相关的功能，所以我们先不要对服务namespace进行注入动作，后续有需要再说。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>创建secret</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl create secret generic  x-abc-com-20211118 --from-file=cert=x.abc.com.cer  --from-file=key=x.abc.com.key -n istio-system</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get secret -n istio-system</span></span><br><span class="line">x-abc-com-20211118                                        Opaque                                2      12s</span><br></pre></td></tr></table></figure><ul><li>创建gateway</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim test.yaml</span></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    host: www.abc.com</span><br><span class="line">  name: gateway-www-abc-com</span><br><span class="line">  namespace: my-cluster1-gateway</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: istio-ingressgateway</span><br><span class="line">    istio: ingressgateway</span><br><span class="line">  servers:</span><br><span class="line">  - hosts:</span><br><span class="line">    - www.abc.com</span><br><span class="line">    port:</span><br><span class="line">      name: www.abc.com-80</span><br><span class="line">      number: 80</span><br><span class="line">      protocol: HTTP</span><br><span class="line">    tls:</span><br><span class="line">      httpsRedirect: true</span><br><span class="line">  - hosts:</span><br><span class="line">    - www.abc.com</span><br><span class="line">    port:</span><br><span class="line">      name: https-www.abc.com-443</span><br><span class="line">      number: 443</span><br><span class="line">      protocol: HTTPS</span><br><span class="line">    tls:</span><br><span class="line">      credentialName: x-abc-com-20211118</span><br><span class="line">      mode: SIMPLE</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f test.yaml</span></span><br></pre></td></tr></table></figure><ul><li>查看gateway监听</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exec</span> it 进入gateway容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -antulp | grep LISTEN | grep -E <span class="string">"80|443"</span></span></span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      17/envoy</span><br><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      17/envoy</span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于是hostnetwork模式，所以到宿主机上看看</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> istio-node <span class="comment"># netstat -antulp | grep LISTEN | grep -E "80|443"</span></span></span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1846819/envoy       </span><br><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      1846819/envoy</span><br></pre></td></tr></table></figure><ul><li>创建一个四层的负载均衡器</li></ul><p>我们创建一个四层的负载均衡器代理到我们的gateway上，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个公网的和一个内网的</span><br><span class="line">2. 代理80和443</span><br><span class="line">3. 健康检查使用15021/healthz/ready</span><br></pre></td></tr></table></figure><p><img src="/img/istio-in-gcp/1.png" alt="png1"></p><ul><li>创建vs</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim vs.yaml</span></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    host: www.abc.com</span><br><span class="line">  name: vs-www.abc.com</span><br><span class="line">  namespace: my-cluster1-vs</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - my-cluster1-gateway/gateway-www-abc-com</span><br><span class="line">  hosts:</span><br><span class="line">  - www.abc.com</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: /</span><br><span class="line">    name: www.abc.com-/</span><br><span class="line">    retries: &#123;&#125;</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: test-svc.test-ns.svc.cluster.local</span><br><span class="line">        port:</span><br><span class="line">          number: 80</span><br><span class="line">      weight: 100</span><br><span class="line">    timeout: 75s</span><br><span class="line">  - match:</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: /api</span><br><span class="line">    name: www.abc.com-/api</span><br><span class="line">    retries: &#123;&#125;</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: test-svc.test-ns.svc.cluster.local</span><br><span class="line">        port:</span><br><span class="line">          number: 80</span><br><span class="line">      weight: 100</span><br><span class="line">    timeout: 75s</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f vs.yaml</span></span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl get gateway -n my-cluster1-gateway</span></span><br><span class="line">NAME                              AGE</span><br><span class="line">gateway-www-abc-com                       16h</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get vs -n my-cluster1-vs</span></span><br><span class="line">NAME                              GATEWAYS                                                   HOSTS                                 AGE</span><br><span class="line">vs-www.abc.com                       ["my-cluster1-gateway/www-abc-com"]                        ["www.abc.com"]                       58m</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl -x your_public_ip:443 <span class="string">"https://www.abc.com"</span> -vvv</span></span><br></pre></td></tr></table></figure><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>目前新的博客地址：<code>dgsfor.com</code><br>托管于：<a href="https://zeno.so/" target="_blank" rel="noopener">zeno</a><br>文档：<a href="https://top7y84e.xvx.app/" target="_blank" rel="noopener">点击我</a></p>]]></content>
    
    
    <summary type="html">如何在gcp上使用istio的gateway</summary>
    
    
    
    <category term="k8s" scheme="https://blog.itmonkey.icu/categories/k8s/"/>
    
    
    <category term="gcp" scheme="https://blog.itmonkey.icu/tags/gcp/"/>
    
    <category term="k8s" scheme="https://blog.itmonkey.icu/tags/k8s/"/>
    
    <category term="istio" scheme="https://blog.itmonkey.icu/tags/istio/"/>
    
    <category term="envory" scheme="https://blog.itmonkey.icu/tags/envory/"/>
    
  </entry>
  
  <entry>
    <title>SRE移动端运维工具- 小程序</title>
    <link href="https://blog.itmonkey.icu/2021/11/14/sre-mobile-tools/"/>
    <id>https://blog.itmonkey.icu/2021/11/14/sre-mobile-tools/</id>
    <published>2021-11-14T14:34:35.000Z</published>
    <updated>2021-11-14T16:03:16.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>你是否有遇到过线上服务出现问题，你还在吃饭、约会、看电影，这时候你怎么办？<br>让我猜测一下，你可能的动作就是：<code>停止手头</code> – <code>打开电脑</code> – <code>拨vpn</code> – <code>看消息</code> – <code>处理问题</code> – <code>回消息</code>.</p><p>这样的场景我猜测很多运维同学都有经历过，就像我一样，去茶卡盐湖处理问题、在高铁站处理问题。</p><img src="/img/sre-mobile-tools/1.png" width="50%" height="50%" alt="1" /><img src="/img/sre-mobile-tools/2.png" width="50%" height="50%" alt="2" /><h2 id="头脑风暴"><a href="#头脑风暴" class="headerlink" title="头脑风暴"></a>头脑风暴</h2><p>我们试想一下，是否可以减轻这种“负担”呢？<br>我个人是比较懒的，电脑束缚了我的玩耍，每次聚餐必然打开电脑处理问题，所以在2019年我就开始在<code>运维是不是可以不背电脑</code>这个方向上做着努力。</p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>在移动端运维上面，我经历了几个方面。</p><ul><li>ios开发(由于自己用iPhone，所以只开发了苹果端，用了swift)</li><li>双端ios和android(用了flutter)</li><li>小程序(原生框架)</li></ul><h4 id="IOS开发"><a href="#IOS开发" class="headerlink" title="IOS开发"></a>IOS开发</h4><p>  对于最初的用swift，我当时做了一些简单的功能(毕竟菜鸟，不会写复杂的)，我之前的一篇文章有简单介绍过，有兴趣的可以看下：<a href="https://blog.itmonkey.icu/2020/06/17/meitu-aliyun-use-experience/">跳转</a></p><h4 id="双端flutter"><a href="#双端flutter" class="headerlink" title="双端flutter"></a>双端flutter</h4><p>  这个本来进展还不错，写的都差不多了，安卓也上线了，可是坑就坑在苹果上，App Store硬是认为我的应用不具有普遍性，被无情拒绝五六次(白瞎了我的开发者账号，我记得是快一千大洋了)。<br>这样不行啊，只有安卓，苹果用户用不了，那不白扯了。最终也是草草了之！</p><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><p>  最终我想到了小程序，目前来说不会受到平台的限制，除非你不玩微信，那我”无fuck说”。<br>最开始写小程序，看了两天的项目实战教程，然后就自己写了，效果还行，“借鉴”了一些开源的样式，整体不算太丑，也是能看。<br>  另外开始搞小程序的时候，有一个缺点就是上架后大家都能用，那肯定不行。所以后面直接转成”企业微信小程序”，绑定到企业微信上，在企业微信上做一些权限控制，目前就是按照这样的状态持续运行着，挺好~</p><h4 id="展示一下-老的"><a href="#展示一下-老的" class="headerlink" title="展示一下(老的)"></a>展示一下(老的)</h4><p>之前用flutter做的app，给大家看个图标吧，内部就不展示了。(whyme是安卓端，mtmops是苹果端)<br><img src="/img/sre-mobile-tools/3.png" alt="3"></p><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>个人觉得这个开发难度不是很大，而且可能存在对于某些同学有些小意义，打算把基础框架给开源出来，包含了：</p><ul><li>后端接口(主要涉及登录认证以及后续接其他功能的接口预留)</li><li>前端页面框架(感觉这个页面还行，简洁明了，适合我自己)</li><li>企业微信登录可以配合公司内部认证使用(比如统一登录OA)</li></ul><p>里面主要分为两种登录方式，<code>企业微信登录</code>和<code>微信登录</code>。<br>备注：企业微信登录要求必须先发布小程序，我就没有写具体的演示代码，我直接改成微信登录了，简单些，需要企业微信登录的照葫芦画瓢就行。</p><p>项目信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/gsgs-libin/handleWhileDrinking</span><br></pre></td></tr></table></figure><p>技术栈：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小程序端：原生微信小程序语言</span><br><span class="line">服务端：go(gin框架)</span><br></pre></td></tr></table></figure><p>正如项目名字所说：在喝酒的时候处理问题，说的就是我经常出去聚餐的时候临时处理问题。</p><h2 id="项目意义"><a href="#项目意义" class="headerlink" title="项目意义"></a>项目意义</h2><ul><li>个人认为算是小小的填补了移动端运维的空白</li><li>提升了简单操作、信息查询的效率，更加便捷</li></ul><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><p>目前我们使用这个移动端运维工具已经一段时间了，带来了一些好处，同时也存在着一些问题：</p><ul><li>在线一键扩容(只需要手机一点就可以扩容)</li><li>监控查看(我们日常的监控报表都可以通过这个来看)</li><li>基本信息查看(日常的一些信息查询都可以查询)</li><li>其他功能</li></ul><p>存在的问题：</p><ul><li>真正大故障你用上，真正有问题可能还是需要你打开电脑</li><li>需求不多，日常都在办公室对着电脑，真正拿手机处理问题又能有几次</li><li>人力不足，目前这个就我一个人维护，虽然也够了，不过还是需要一些能力更强的人加入到建设中</li></ul><h2 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h2><h4 id="整体页面"><a href="#整体页面" class="headerlink" title="整体页面"></a>整体页面</h4><p><img src="/img/sre-mobile-tools/4.png" alt="4"><br><img src="/img/sre-mobile-tools/5.png" alt="5"><br><img src="/img/sre-mobile-tools/6.png" alt="6"><br><img src="/img/sre-mobile-tools/7.png" alt="7"></p><h4 id="登录相关"><a href="#登录相关" class="headerlink" title="登录相关"></a>登录相关</h4><p><img src="/img/sre-mobile-tools/8.png" alt="8"><br><img src="/img/sre-mobile-tools/9.png" alt="9"></p><h4 id="企业微信登录"><a href="#企业微信登录" class="headerlink" title="企业微信登录"></a>企业微信登录</h4><p>这个是我们公司正在使用的小程序端，企业微信登录的，配合了公司内部统一登录获取了一些用户信息相关的然后进行展示。</p><p><img src="/img/sre-mobile-tools/10.png" alt="10"><br><img src="/img/sre-mobile-tools/11.png" alt="11"></p>]]></content>
    
    
    <summary type="html">移动端运维工具，解放你的电脑</summary>
    
    
    
    <category term="DevOps" scheme="https://blog.itmonkey.icu/categories/DevOps/"/>
    
    
    <category term="sre" scheme="https://blog.itmonkey.icu/tags/sre/"/>
    
    <category term="移动端运维" scheme="https://blog.itmonkey.icu/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BF%90%E7%BB%B4/"/>
    
    <category term="小程序" scheme="https://blog.itmonkey.icu/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>SRE稳定性运营平台之 巡检和运营报告</title>
    <link href="https://blog.itmonkey.icu/2021/11/12/sre-stability-operation-platform-report/"/>
    <id>https://blog.itmonkey.icu/2021/11/12/sre-stability-operation-platform-report/</id>
    <published>2021-11-12T09:01:45.000Z</published>
    <updated>2021-11-12T13:07:23.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>继续上集说到，持续更新我的SRE稳定性运营平台，上次我们介绍了权威消息和模板相关的功能。<br>没看过的可以点击这里：<a href="https://blog.itmonkey.icu/2021/11/09/sre-stability-operation-platform-authority-message/">跳转</a></p><h2 id="新功能介绍"><a href="#新功能介绍" class="headerlink" title="新功能介绍"></a>新功能介绍</h2><p>本次主要介绍<code>报告模块</code>，这个模块是这个平台的核心模块。<br>所谓报告，我们日常会接触到的报告有什么？</p><p>1.业务日报、周报、月报、年报<br>2.业务巡检报告<br>3.业务成本报告<br>4.等等</p><p>那么对于这些报告来说，我们可以手动输出也可以自动生成，当然对于这个平台来说，我们核心的功能就是<code>接管了报告生成步骤中最繁琐的数据收集和渲染过程</code>。<br>所以他的功能就是：</p><ul><li>支持创建各种报告</li><li>支持插槽批注(在报告中预留位置，可以后续进行不同人的批注)</li></ul><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><p>对于这个新功能，我们可以通过下面的步骤进行快速上手：</p><ol><li>创建报告模板</li><li>编写模板内容(设置变量、设置插槽)</li><li>注册变量、注册插槽</li><li>渲染报告并合并</li><li>预览报告、完结报告</li></ol><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h4 id="1、2"><a href="#1、2" class="headerlink" title="1、2"></a>1、2</h4><p>1、2步骤跟之前文章有重复，请看上一篇文章：<a href="https://blog.itmonkey.icu/2021/11/09/sre-stability-operation-platform-authority-message/">跳转</a></p><h4 id="注册插槽"><a href="#注册插槽" class="headerlink" title="注册插槽"></a>注册插槽</h4><p><img src="/img/sre-stability-operation-platform/10-1.png" alt="10"></p><h4 id="创建报告、渲染、合并"><a href="#创建报告、渲染、合并" class="headerlink" title="创建报告、渲染、合并"></a>创建报告、渲染、合并</h4><p>创建一个报告<br><img src="/img/sre-stability-operation-platform/11.png" alt="11"></p><p>渲染报告<br><img src="/img/sre-stability-operation-platform/12.png" alt="12"></p><p>查看渲染进度,会看到每一个变量的渲染结果，然后渲染完成之后可以点击合并把渲染后的内容合并到报告里<br><img src="/img/sre-stability-operation-platform/13.png" alt="13"></p><h4 id="编写插槽内容"><a href="#编写插槽内容" class="headerlink" title="编写插槽内容"></a>编写插槽内容</h4><p>针对具体的报告，我们可以对插槽进行内容批注，最终也会合并到报告主体中<br><img src="/img/sre-stability-operation-platform/14.png" alt="14"></p><h4 id="预览报告"><a href="#预览报告" class="headerlink" title="预览报告"></a>预览报告</h4><p>预览报告，最终也可以把这个报告发送出去(注意：预览的报告是不需要登录的)<br><img src="/img/sre-stability-operation-platform/15.png" alt="15"></p>]]></content>
    
    
    <summary type="html">如何打造一个企业级使用的sre稳定性运营平台</summary>
    
    
    
    <category term="sre-report" scheme="https://blog.itmonkey.icu/categories/sre-report/"/>
    
    
    <category term="sre" scheme="https://blog.itmonkey.icu/tags/sre/"/>
    
    <category term="devops" scheme="https://blog.itmonkey.icu/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>SRE稳定性运营平台之模板和权威消息</title>
    <link href="https://blog.itmonkey.icu/2021/11/09/sre-stability-operation-platform-authority-message/"/>
    <id>https://blog.itmonkey.icu/2021/11/09/sre-stability-operation-platform-authority-message/</id>
    <published>2021-11-09T05:12:21.000Z</published>
    <updated>2021-11-09T08:05:09.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们逐步由运维转向SRE、SRE转向成SRE运营的过程中，我们的工作内容和工作重心都有着慢慢的变化。<br>在这个转变的过程中，我们需要不断的把这些日常工作或者是定期工作逐步沉淀、不断的创新，那么就会带来两种东西：</p><ul><li>第一：<code>工具平台</code></li><li>第二：<code>特色输出</code></li></ul><p>工具能够协助我们快速、自动化、智能的完成工作；特色输出能够告诉外界你们做了什么，更重要的是它代表SRE独有，对于提高部门影响力起到一个关键作用以及也是重要途径之一。</p><blockquote><p>备注：之前有写过一篇关于运营报告平台的介绍，可以简单看下，写的更具体一点：<a href="https://blog.itmonkey.icu/2021/07/13/ops_report/report-01/">点击我跳转</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前我基于在公司做的稳定性运营平台，抽离了部分功能以及脱离了公司的一些框架，输出了一版使用开源框架做的运营平台。<br>这个平台会持续更新，当然可能会慢于公司的版本更新。</p><p>项目地址：<a href="https://github.com/gsgs-libin/sre_cerebrum" target="_blank" rel="noopener">点击我跳转</a></p><p>开源版本的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前端：https://github.com/gsgs-libin/sre_cerebrum</span><br><span class="line">后端：https://github.com/gsgs-libin/sre_cerebrum_api</span><br><span class="line">前端框架：ant-design-vue-pro</span><br><span class="line">后端框架：gin</span><br></pre></td></tr></table></figure><p>开源版本的优势：</p><ul><li>更丰富的日志输出</li><li>更好的规范</li><li>更好看的界面</li></ul><h2 id="公司内部版本功能"><a href="#公司内部版本功能" class="headerlink" title="公司内部版本功能"></a>公司内部版本功能</h2><p>目前公司内部的项目已有的一些功能有：<br>1.业务周报、SRE运营报告、巡检报告等一系列报告的输出<br>2.业务巡检覆盖<br>3.SRE权威消息发布(包含一切核心消息同步)<br>4.通知渠道注册<br>5.SRE事件编排(SRE轮值、节假日轮值、周期性事件)<br>6.业务基础数据采集(qps，sla，带宽，db资源信息等)<br>7.定时任务</p><h2 id="开源版本"><a href="#开源版本" class="headerlink" title="开源版本"></a>开源版本</h2><p>这次先实现了权威消息模块以及渠道通知模块，平台有一个基础模块就是模板，所有的报告、消息都是基于模板来实现的。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>权威消息起初设计的目的是覆盖SRE内部日常对内对外的消息，包括：</p><ul><li>各式各样的通知(该写周报了、该巡检了、该处理问题了)</li><li>对外轮值通知(告诉业务方今天是谁轮值)</li><li>故障消息(发生了什么故障、故障恢复了等等的通知，权威通知，防止群里七嘴八舌的)</li><li>定时发送的消息</li></ul><h2 id="如何创建权威消息"><a href="#如何创建权威消息" class="headerlink" title="如何创建权威消息"></a>如何创建权威消息</h2><h4 id="1-创建权威消息模板"><a href="#1-创建权威消息模板" class="headerlink" title="1.创建权威消息模板"></a>1.创建权威消息模板</h4><p><img src="/img/sre-stability-operation-platform/1.png" alt="png1"></p><h4 id="2-编辑模板内容"><a href="#2-编辑模板内容" class="headerlink" title="2.编辑模板内容"></a>2.编辑模板内容</h4><p>模板内容可以是静态内容也可以是变量模式，比如可以用一个变量来替代你要发送的消息内容。</p><p>如果没有变量可以这样：<br><img src="/img/sre-stability-operation-platform/2.png" alt="png2"><br>如果有变量可以在内容增加写一个变量，然后在下面变量列表中写上：<br> <img src="/img/sre-stability-operation-platform/3.png" alt="png3"></p><h4 id="3-变量注册"><a href="#3-变量注册" class="headerlink" title="3.变量注册"></a>3.变量注册</h4><p>如果在编辑模板的过程中增加了变量，那么我们需要注册下这个变量，意思就是我从哪里获取到你这个变量。<br>目前变量分了三种：<code>内置变量</code>，<code>自定义变量</code>，<code>图片变量</code>。<br>内置变量就是注册一次谁都可以用，自定义变量和图片变量都是跟具体的模板绑定的。</p><p><img src="/img/sre-stability-operation-platform/4.png" alt="png4"></p><p>注册完成之后，可以看看这个变量的详情：<br><img src="/img/sre-stability-operation-platform/5.png" alt="png5"></p><h4 id="4-通知渠道注册"><a href="#4-通知渠道注册" class="headerlink" title="4.通知渠道注册"></a>4.通知渠道注册</h4><p>顾名思义，就是创建一些可以通知消息的渠道，比如<code>企业微信机器人</code>，<code>企业微信应用</code>，<code>钉钉机器人</code>，<code>邮件</code>，<code>短信</code>等等。<br>由于公司内部使用企业微信，所以我目前就实现了注册机器人和应用的功能，其他的有需求再加，或者可以提pr。</p><p><img src="/img/sre-stability-operation-platform/6.png" alt="png6"></p><h4 id="4-创建消息"><a href="#4-创建消息" class="headerlink" title="4.创建消息"></a>4.创建消息</h4><p>我们的每一条消息都是基于模板的，所以我们需要在模板位置去创建消息。<br>创建消息会经历的步骤：创建动作–渲染动作(如果有变量)–合并动作(如果有变量)–审核动作(如果是需要审核的)–发送</p><p><img src="/img/sre-stability-operation-platform/7.png" alt="png7"></p><h4 id="5-查看消息渲染进度-如果有变量的话"><a href="#5-查看消息渲染进度-如果有变量的话" class="headerlink" title="5.查看消息渲染进度(如果有变量的话)"></a>5.查看消息渲染进度(如果有变量的话)</h4><p><img src="/img/sre-stability-operation-platform/8.png" alt="png8"></p><h4 id="6-发送或者审核"><a href="#6-发送或者审核" class="headerlink" title="6.发送或者审核"></a>6.发送或者审核</h4><p>在这里你可以对消息进行一系列的操作，比如：</p><ul><li>测试发送消息</li><li>看下发送历史，到底被发送了多少次</li><li>编辑，如果消息内容不理想，可以进行二次编辑</li><li>审核(当然需要审核人员才行，可以看后端代码定义)</li><li>废弃(创建消息的人可以选择主动废弃)</li></ul><p><img src="/img/sre-stability-operation-platform/9.png" alt="png9"></p><p><img src="/img/sre-stability-operation-platform/10.png" alt="png10"></p><p><img src="/img/sre-stability-operation-platform/11.png" alt="png11"></p><h2 id="下期介绍"><a href="#下期介绍" class="headerlink" title="下期介绍"></a>下期介绍</h2><p>下期会发布新功能：报告相关(运营报告、巡检报告等等)</p>]]></content>
    
    
    <summary type="html">如何打造一个企业级使用的sre稳定性运营平台</summary>
    
    
    
    <category term="sre-report" scheme="https://blog.itmonkey.icu/categories/sre-report/"/>
    
    
    <category term="sre" scheme="https://blog.itmonkey.icu/tags/sre/"/>
    
    <category term="devops" scheme="https://blog.itmonkey.icu/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>基于DCGM的ubuntu GPU监控方案</title>
    <link href="https://blog.itmonkey.icu/2021/10/26/ubuntu-gpu-monitor-prometheus/"/>
    <id>https://blog.itmonkey.icu/2021/10/26/ubuntu-gpu-monitor-prometheus/</id>
    <published>2021-10-26T08:50:15.000Z</published>
    <updated>2021-10-26T09:50:29.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>手上有几台gpu机器，目前没有单独加入到k8s集群，所以需要单独装一下监控来观察他的利用率情况。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>目前使用<a href="https://github.com/NVIDIA/gpu-monitoring-tools" target="_blank" rel="noopener">NVIDIA/gpu-monitoring-tools</a>来做监控，然后对接prometheus。</p><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">机器型号：inux version 4.15.0-136-generic (buildd@lcy01-amd64-029) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #140-Ubuntu SMP Thu Jan 28 05:20:47 UTC 2021</span><br><span class="line">gpu版本：NVIDIA-SMI 450.80.02    Driver Version: 450.80.02    CUDA Version: 11.0</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt  install docker.io</span><br></pre></td></tr></table></figure><h4 id="部署exporter"><a href="#部署exporter" class="headerlink" title="部署exporter"></a>部署exporter</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --gpus all --rm -p 9400:9400 nvcr.io/nvidia/k8s/dcgm-exporter:2.0.13-2.1.2-ubuntu18.04</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:9400/metrics</span><br></pre></td></tr></table></figure><h4 id="GPU指标说明"><a href="#GPU指标说明" class="headerlink" title="GPU指标说明"></a>GPU指标说明</h4><p>可以参考下这个文章：<a href="https://blog.csdn.net/weichuangxxb/article/details/105330857" target="_blank" rel="noopener">点击</a></p><h2 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h2><p>如果在部署exporter的时候报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: could not select device driver "" with capabilities: [[gpu]].</span><br></pre></td></tr></table></figure><p>请这样处理：(记住一定要重启下docker)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</span><br><span class="line">2. curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -</span><br><span class="line">3. curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line">4. apt-get update</span><br><span class="line">5. apt-get install nvidia-container-toolkit</span><br><span class="line">6. systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="配置prometheus"><a href="#配置prometheus" class="headerlink" title="配置prometheus"></a>配置prometheus</h2><p>部署好之后，我们需要配置下prometheus，新增一个target：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- job_name: 'GpuMonitor'</span><br><span class="line">  scrape_interval: 300s</span><br><span class="line">  scrape_timeout: 300s</span><br><span class="line">  metrics_path: /metrics</span><br><span class="line">  scheme: http</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets:</span><br><span class="line">    - 10.10.10.1:9400</span><br><span class="line">    - 10.10.10.2:9400</span><br></pre></td></tr></table></figure><h2 id="配置grafana"><a href="#配置grafana" class="headerlink" title="配置grafana"></a>配置grafana</h2><p>grafana模板到官方网站找一个，很多都可以，我用的这个模板：<a href="https://grafana.com/grafana/dashboards/12639" target="_blank" rel="noopener">grafana模板</a></p><p>导入之后看看效果<br><img src="/img/ubuntu-gpu-monitor-prometheus/1.png" alt="png1"></p>]]></content>
    
    
    <summary type="html">通过dcgm来监控GPU</summary>
    
    
    
    <category term="k8s" scheme="https://blog.itmonkey.icu/categories/k8s/"/>
    
    
    <category term="prometheus" scheme="https://blog.itmonkey.icu/tags/prometheus/"/>
    
    <category term="gpu" scheme="https://blog.itmonkey.icu/tags/gpu/"/>
    
    <category term="grafana" scheme="https://blog.itmonkey.icu/tags/grafana/"/>
    
  </entry>
  
  <entry>
    <title>实现华为云cce集群双GPU版本共存</title>
    <link href="https://blog.itmonkey.icu/2021/08/31/hwcloud-cce-dual-gpu-version-coexist/"/>
    <id>https://blog.itmonkey.icu/2021/08/31/hwcloud-cce-dual-gpu-version-coexist/</id>
    <published>2021-08-31T06:31:08.000Z</published>
    <updated>2021-08-31T10:21:54.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在使用华为云cce集群的时候，使用gpu插件来扩展我们集群的gpu能力。<br>不过我们服务有更新，需要更高的gpu版本来支撑，但是老的又不能下。<br>所以我们采用双gpu版本共存来实现需求。</p><h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><p>华为云目前一个集群只支持安装一个版本的gpu插件，所以我们需要知道他的gpu插件工作原理，单独实现一个。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>我们发现华为云的gpu插件其实是两个ds来工作的，<code>nvidia-driver-installer</code>和<code>nvidia-gpu-device-plugin</code>。<br>功能简单来说就是，在node节点上下载好gpu驱动，解压到特定目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ k get ds -n kube-system</span><br><span class="line">NAME                           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                      AGE</span><br><span class="line">icagent                        120       120       120     120          120         &lt;none&gt;                             517d</span><br><span class="line">nvidia-driver-installer        60        60        60      9            60          &lt;none&gt;                             467d</span><br><span class="line">nvidia-gpu-device-plugin       60        60        60      9            60          &lt;none&gt;                             467d</span><br><span class="line">storage-driver                 120       120       120     120          120         &lt;none&gt;                             517d</span><br></pre></td></tr></table></figure><ol><li>现在我们直接复制这两个ds的yaml文件，然后修改里面的name以及标签为<code>nvidia-driver-installer-460</code>和<code>nvidia-gpu-device-plugin-460</code>，你可以简单的认为做一下区分就好了。</li><li>创建两种节点池，然后分别打上标签为<code>gpu_type=gpu-418</code>和<code>gpu_type=gpu-460</code></li><li>分别修改四个ds，然后加上<code>nodeselector</code>，如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodeSelector:</span><br><span class="line">  gpu_type=gpu-418 或者 gpu_type=gpu-460</span><br></pre></td></tr></table></figure></li><li>最后apply，查看效果<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ k get ds -n kube-system</span><br><span class="line">NAME                           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                      AGE</span><br><span class="line">icagent                        120       120       120     120          120         &lt;none&gt;                             517d</span><br><span class="line">nvidia-driver-installer        60        60        60      9            60          gpu_type=gpu-418                   467d</span><br><span class="line">nvidia-driver-installer-460    43        43        43      17           43          gpu_type=gpu-460                   194d</span><br><span class="line">nvidia-gpu-device-plugin       60        60        60      9            60          gpu_type=gpu-418                   467d</span><br><span class="line">nvidia-gpu-device-plugin-460   43        43        43      16           43          gpu_type=gpu-460                   194d</span><br><span class="line">storage-driver                 120       120       120     120          120         &lt;none&gt;                             517d</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">如何在华为云cce集群中共存两种gpu版本</summary>
    
    
    
    <category term="云运维" scheme="https://blog.itmonkey.icu/categories/%E4%BA%91%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="k8s" scheme="https://blog.itmonkey.icu/tags/k8s/"/>
    
    <category term="华为云" scheme="https://blog.itmonkey.icu/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
    
    <category term="GPU" scheme="https://blog.itmonkey.icu/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>gcp如何限制某台机器公网流量，放行内网流量</title>
    <link href="https://blog.itmonkey.icu/2021/08/27/gcp-firewalls-restrict-release-of-public-networks-to-the-intranet/"/>
    <id>https://blog.itmonkey.icu/2021/08/27/gcp-firewalls-restrict-release-of-public-networks-to-the-intranet/</id>
    <published>2021-08-27T07:38:40.000Z</published>
    <updated>2021-08-27T07:46:29.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当前有一台带公网ip的机器，网络标记是：<code>datax</code>，我们期望的状态是：</p><ol><li>公网只放行8080、8793端口</li><li>内网只允许22端口</li></ol><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><ol><li>新增入站规则，目标是网络标记为datax，来源<code>0.0.0.0/0</code>，允许8080和8974端口，优先级为1</li><li>新增入站规则，目标是网络标记为datax，来源是<code>10.0.0.0/8</code>(这个看你们内网网段是多少)，允许22端口，优先级为2</li><li>新增入站规则，目标是网络标记为datax，来源是<code>0.0.0.0/0</code>，拒绝所有流量，优先级为3</li></ol><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p><img src="/img/gcp-firewalls-restrict-release-of-public-networks-to-the-intranet/img.png" alt="png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;当前有一台带公网ip的机器，网络标记是：&lt;code&gt;datax&lt;/code&gt;，我们期望的状态是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;公网只放行808</summary>
      
    
    
    
    <category term="云运维" scheme="https://blog.itmonkey.icu/categories/%E4%BA%91%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="gcp" scheme="https://blog.itmonkey.icu/tags/gcp/"/>
    
    <category term="firewalls" scheme="https://blog.itmonkey.icu/tags/firewalls/"/>
    
  </entry>
  
  <entry>
    <title>编程时间处理</title>
    <link href="https://blog.itmonkey.icu/2021/07/21/ops-time/"/>
    <id>https://blog.itmonkey.icu/2021/07/21/ops-time/</id>
    <published>2021-07-21T03:12:05.000Z</published>
    <updated>2021-07-21T05:56:21.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><a id="more"></a><blockquote><p>获取字符串时间</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_time :=time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>时间差计算</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start_time :=time.Now()</span><br><span class="line">end_time :=time.Now()</span><br><span class="line">d := end_time.Sub(start_time)</span><br></pre></td></tr></table></figure><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.setTime(<span class="keyword">new</span> Date());</span><br><span class="line">SimpleDateFormat hourPoint = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd-HH"</span>);</span><br><span class="line">SimpleDateFormat dayPoint = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">String hourPointDate = hourPoint.format(c.getTime());</span><br><span class="line">String dayPointDate = dayPoint.format(c.getTime());</span><br><span class="line"><span class="keyword">long</span> NowTime = c.getTimeInMillis();</span><br><span class="line">c.add(Calendar.HOUR, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> OneHourAgoTime = c.getTimeInMillis();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于各类编程语言在`时间`上的处理方法</summary>
    
    
    
    <category term="DevOps" scheme="https://blog.itmonkey.icu/categories/DevOps/"/>
    
    
    <category term="time" scheme="https://blog.itmonkey.icu/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>稳定性报告(report)平台 -- 模板篇</title>
    <link href="https://blog.itmonkey.icu/2021/07/15/ops_report/report-02/"/>
    <id>https://blog.itmonkey.icu/2021/07/15/ops_report/report-02/</id>
    <published>2021-07-15T05:37:17.000Z</published>
    <updated>2021-07-16T07:37:46.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>后续我们称这个平台为<code>srp</code>平台。</p><a id="more"></a><p>后续的每一个模块，基本上会通过几个方面来介绍：</p><ol><li>基础讲解</li><li>数据库设计</li><li>核心功能介绍</li><li>简单展示</li></ol><h3 id="基础讲解"><a href="#基础讲解" class="headerlink" title="基础讲解"></a>基础讲解</h3><p>模板篇，我会把模板和变量注册放在一起讲解，因为两个关联性比较大，所以一起讲解会比较容易点。<br>前面说到，我们的模板分成了三种类型：</p><table><thead><tr><th align="left">模板类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">基础模板</td><td align="left">基础模板主要提供接入能力，比如我定义好了域名QPS统计的能力，那么你只需要提供你的域名，我就可以帮你完成统计动作</td></tr><tr><td align="left">开放模板/周期模板</td><td align="left">这类模板就相对自由，你可以自定义模板内容，变量，最终定义定时任务来定时的渲染该模板，然后选择发送等</td></tr></tbody></table><h4 id="基础模板"><a href="#基础模板" class="headerlink" title="基础模板"></a>基础模板</h4><p>首先对于基础模板，换个概念理解就是平台已经约定了这个模板只会采集某一类型的数据，然后对于用户来讲，你只需要关注<code>要不要</code>采集即可。</p><p>举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我创建一个统计`QPS峰值`的模板，这个模板主要是统计每一个注册进来的域名过去1小时的峰值，而且是每小时统计一次。</span><br><span class="line">那么对于用户来讲，我只需要增加注册即可，比如我有一个a域名，那么新增注册，告诉平台我这个域名希望加入统计。</span><br></pre></td></tr></table></figure><p><img src="/img/ops_report/02/1.png" alt="png1"></p><p>像这种模板还有很多，比如带宽、nat网关、负载均衡等等，都可以当成基础模板来使用，用户只需接入即可，不用配置更多。</p><h4 id="开放模板-周期模板"><a href="#开放模板-周期模板" class="headerlink" title="开放模板/周期模板"></a>开放模板/周期模板</h4><p>其实当初定义了两种类型，最后发现没有实际上的差别，所以就放到一起讲吧。<br>这里我统称为自定义模板吧，字面意义上理解就是完全自定义，你可以定义你想要的报告的样子，比如下面：</p><p><img src="/img/ops_report/02/2.png" alt="png2"></p><p>我这变用了一个markdown编辑器来做，目前我们都是通过markdown格式的数据来展示报告，你可以跟日常写markdown文档一样就行。<br>当你在某个位置想要用变量展示，那么定义一个变量名称，然后在下面添加就行，这个变量可以是图片变量、内置变量、模板变量。</p><h4 id="变量注册"><a href="#变量注册" class="headerlink" title="变量注册"></a>变量注册</h4><p>我们定义好开放模板之后，以及也增加好了里面的变量。现在就需要去注册变量，本质就是告诉平台我这个变量是什么意思，怎么获取到这个值。</p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>首先对于模板表，我这边主要设计了以下几个字段：(唯一需要关注的就是Content字段，本身是markdown内容，所以设置成了TEXT类型)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板表</span></span><br><span class="line"><span class="keyword">type</span> ReportTemplate <span class="keyword">struct</span> &#123;</span><br><span class="line">BaseModel</span><br><span class="line">TemplateId <span class="keyword">string</span> <span class="string">`json:"template_id"`</span>                            <span class="comment">// 模板id</span></span><br><span class="line">Name       <span class="keyword">string</span> <span class="string">`json:"name"`</span>                                   <span class="comment">// 模板名称</span></span><br><span class="line">Creater    <span class="keyword">string</span> <span class="string">`json:"creater"`</span>                                <span class="comment">// 创建人</span></span><br><span class="line">Status     <span class="keyword">string</span> <span class="string">`json:"status"`</span>                                 <span class="comment">// 模板状态 禁用，可用 enable disable</span></span><br><span class="line">Type       <span class="keyword">string</span> <span class="string">`json:"type"`</span>                                   <span class="comment">// 模板类型，基础模板(base_temp)，开放模板(open_temp)，周期模板(cron_temp)</span></span><br><span class="line">Router     <span class="keyword">string</span> <span class="string">`json:"router" gorm:"default:null"`</span>             <span class="comment">// 前端跳转路由</span></span><br><span class="line">Content    <span class="keyword">string</span> <span class="string">`json:"content" gorm:"type:TEXT;default:null"`</span>  <span class="comment">// markdown内容</span></span><br><span class="line">VarList    <span class="keyword">string</span> <span class="string">`json:"var_list" gorm:"type:TEXT;default:null"`</span> <span class="comment">// 变量json串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次是变量表：(变量参数是指请求url的时候带上什么参数，获取字段是指请求的结果中我用哪个字段的数据)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量注册表</span></span><br><span class="line"><span class="keyword">type</span> ReportTemplateVar <span class="keyword">struct</span> &#123;</span><br><span class="line">BaseModel</span><br><span class="line">VarTempId   <span class="keyword">string</span> <span class="string">`json:"var_temp_id"`</span>                    <span class="comment">// 模板id</span></span><br><span class="line">VarName     <span class="keyword">string</span> <span class="string">`json:"var_name"`</span>                       <span class="comment">// 变量名称</span></span><br><span class="line">VarUrl      <span class="keyword">string</span> <span class="string">`json:"var_url" gorm:"type:TEXT"`</span>       <span class="comment">// 变量获取地址</span></span><br><span class="line">VarUrlField <span class="keyword">string</span> <span class="string">`json:"var_url_field"`</span>                  <span class="comment">// 变量结果获取字段</span></span><br><span class="line">VarType     <span class="keyword">string</span> <span class="string">`json:"var_type"`</span>                       <span class="comment">// 变量类型 ,内置变量、自定义变量、图片变量，inner_temp_var、custom_temp_var、img_temp_var</span></span><br><span class="line">VarParams   <span class="keyword">string</span> <span class="string">`json:"var_params" gorm:"default:null"`</span> <span class="comment">// 变量参数</span></span><br><span class="line">VarDesc     <span class="keyword">string</span> <span class="string">`json:"var_desc" gorm:"default:null"`</span>   <span class="comment">// 变量备注，变量说明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是基础模板的话，我们其实还会涉及到一个接入信息，比如我有一个qps的基础模板，那么接入表里面就会涉及到，哪个域名，什么path等：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// qps峰值模板接入表，当前默认规定该模板下的接入，都是定时1小时获取数据一次，并存储数据。</span></span><br><span class="line"><span class="keyword">type</span> QPSPeakBaseTemp <span class="keyword">struct</span> &#123;</span><br><span class="line">model.BaseModel</span><br><span class="line">Aid            <span class="keyword">string</span> <span class="string">`json:"aid"`</span>              <span class="comment">// 接入id</span></span><br><span class="line">Name           <span class="keyword">string</span> <span class="string">`json:"name"`</span>             <span class="comment">// 接入名称</span></span><br><span class="line">Domain         <span class="keyword">string</span> <span class="string">`json:"domain"`</span>           <span class="comment">// 接入域名</span></span><br><span class="line">LoadBalanceBiz <span class="keyword">string</span> <span class="string">`json:"load_balance_biz"`</span> <span class="comment">// lb分组</span></span><br><span class="line">Path           <span class="keyword">string</span> <span class="string">`json:"path"`</span>             <span class="comment">// 域名path</span></span><br><span class="line">Group          <span class="keyword">string</span> <span class="string">`json:"group"`</span>            <span class="comment">// 业务组</span></span><br><span class="line">Creater        <span class="keyword">string</span> <span class="string">`json:"creater"`</span>          <span class="comment">// 创建人</span></span><br><span class="line">Status         <span class="keyword">string</span> <span class="string">`json:"status"`</span>           <span class="comment">// 接入状态 禁用，可用 enable disable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心功能介绍"><a href="#核心功能介绍" class="headerlink" title="核心功能介绍"></a>核心功能介绍</h3><p>其实对于模板来讲，没啥核心功能，就是简单的crud。</p><blockquote><p>前端的markdown表单</p></blockquote><p>使用的是一个开源的markdown插件，git地址：<code>https://github.com/hinesboy/mavonEditor</code></p><p>注册完成之后，可以很容易就创建一个markdown编辑框：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;v-md-editor v-model&#x3D;&quot;markdownContent&quot; height&#x3D;&quot;500px&quot;&gt;&lt;&#x2F;v-md-editor&gt;</span><br></pre></td></tr></table></figure><blockquote><p>变量注册</p></blockquote><p>因为涉及到几种变量类型，所以需要分别做处理。</p><p>内置变量：其实就是平台提供好的变量，我这边主要是定义了一些基础的，比如时间的获取、某个域名的QPS峰值获取、某个nat网关的峰值获取等<br>自定义变量：就是用户自己提供的url，返回值需要按照一定的格式来填写<br>图片变量：目前主要是对接grafana，每一个grafana的panel都可以生成一个图片地址</p><p>比如：<br><code>https://grafana.baidu.com/render/d-solo/BvV4IsPWk/nat?from=000000000&amp;orgId=63&amp;to=000000000&amp;panelId=2&amp;width=1000&amp;height=500&amp;tz=Asia%2FShanghai</code><br>我在注册的时候就会替换里面的<code>from</code>和<code>to</code>两个时间，因为时间需要可传参，结果就是这样：<br><code>https://grafana.baidu.com/render/d-solo/BvV4IsPWk/nat?from=SVAR_START_TIME&amp;orgId=63&amp;to=SVAR_END_TIME&amp;panelId=2&amp;width=1000&amp;height=500&amp;tz=Asia%2FShanghai</code></p><h3 id="简单展示"><a href="#简单展示" class="headerlink" title="简单展示"></a>简单展示</h3><p>模板列表：(不同的模板类型，他的操作按钮也是不一样的)<br><img src="/img/ops_report/02/3.png" alt="png3"></p><p>变量列表：<br><img src="/img/ops_report/02/4.png" alt="png4"></p>]]></content>
    
    
    <summary type="html">详细介绍下稳定性报告平台中模板模块的实现原理和方式</summary>
    
    
    
    <category term="Report" scheme="https://blog.itmonkey.icu/categories/Report/"/>
    
    
    <category term="运营报告" scheme="https://blog.itmonkey.icu/tags/%E8%BF%90%E8%90%A5%E6%8A%A5%E5%91%8A/"/>
    
    <category term="巡检" scheme="https://blog.itmonkey.icu/tags/%E5%B7%A1%E6%A3%80/"/>
    
  </entry>
  
  <entry>
    <title>稳定性报告(report)平台思考</title>
    <link href="https://blog.itmonkey.icu/2021/07/13/ops_report/report-01/"/>
    <id>https://blog.itmonkey.icu/2021/07/13/ops_report/report-01/</id>
    <published>2021-07-13T05:44:01.000Z</published>
    <updated>2021-07-16T07:37:36.625Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>首先说一些日常工作场景：</p><ol><li>你的群里是否经常会发送一些巡检报告，比如qps峰值统计，cpu利用率，机器使用数量统计等等</li><li>你的领导是否需要你每周发送一次公司业务层级的运行报告，包括上周有没有故障，上周所有业务的qps峰值是多少，周期内的一些业务变更或者运营活动等。</li></ol><a id="more"></a><p>所以你可能会看到类似这样的一些图：<br><img src="/img/ops_report/01/1.png" alt="png1"><br><img src="/img/ops_report/01/2.png" alt="png2"><br><img src="/img/ops_report/01/3.png" alt="png3"></p><h3 id="初步思考"><a href="#初步思考" class="headerlink" title="初步思考"></a>初步思考</h3><p>基于上述的背景，我们常规的实现方式有以下几种：</p><ol><li>日常的巡检报告，我们可能会用一个脚本定期的获取数据，然后发送到企业微信机器人、邮箱、钉钉等</li><li>周、月巡检报告运营报告这些，我们可能需要手动创建一个md文件，写上一些数据，截上一些监控图，加上一部分解读和批注，最终发到群里给大家看。</li></ol><p>那么基于上述的实现方式，我们是否可以进一步的去考虑<code>自动化</code>或者说是<code>平台化</code>。比如是否可以设想一下：</p><ol><li>把日常的报告、通知发送集中起来管理(目前可能是一个人一个脚本，不知道跑在哪个机器的定时任务上)</li><li>是否可以模板化，比如定制一些模板，然后拿着这个模板去渲染真实的数据，最终发送出来</li><li>还可以增加定时任务，比如针对这个模板，我想要定期发送，这样就更简单的托管起来我们分部在各个机器上的定时脚本了</li></ol><h3 id="功能期望"><a href="#功能期望" class="headerlink" title="功能期望"></a>功能期望</h3><p>针对上述的思考，我们团队做了一些建设，目前一期建设想要产出一个<code>稳定性运营平台</code>，这个平台目前的任务主要有以下几个：</p><blockquote><ol><li>接管我们当前的日常报告的功能(目前的报告都是自动化脚本实现，定期发送qps数据，带宽数据，网关数据等)</li><li>提供自定义模板功能，能快速定义想要的数据模板</li><li>可以实现监控图的发送(目前更多的是grafana的图片)</li><li>接管我们当前每周的稳定性运营报告的工作，可自动渲染数据，可自定义标注，最终发送<code>终版报告</code>给到用户</li><li>历史数据的存储，目前监控平台会存储全量数据，这个平台只是想要存储一些特定数据或者叫做过滤后有效的数据</li><li>实现定期发送的功能，可配置定时任务</li></ol></blockquote><h3 id="平台设计"><a href="#平台设计" class="headerlink" title="平台设计"></a>平台设计</h3><p>首先这个平台分成了三个大的部分：<code>前端</code>、<code>后端接口</code>、<code>定时任务端</code></p><p>这里主要讲解一下非前端部分，首先功能模块分了几个大块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">仪表盘模块</span><br><span class="line">模板模块</span><br><span class="line">变量注册模块</span><br><span class="line">报告模块</span><br><span class="line">数据存储模块</span><br><span class="line">定时任务模块</span><br></pre></td></tr></table></figure><h4 id="仪表盘模块"><a href="#仪表盘模块" class="headerlink" title="仪表盘模块"></a>仪表盘模块</h4><p>这一块主要是总览展示的功能模块，包括整个平台有多少模板，有多少报告等。<br>这一快的功能放到二期了，一起暂时没做，不过有一个初版的样子可以看看。</p><p><img src="/img/ops_report/01/4.png" alt="png4"></p><h4 id="模板模块"><a href="#模板模块" class="headerlink" title="模板模块"></a>模板模块</h4><p>模板模块和变量注册模块是相辅相成的。模板目前主要划分了几种类型：</p><table><thead><tr><th align="left">模板类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">基础模板</td><td align="left">基础模板主要提供接入能力，比如我定义好了域名QPS统计的能力，那么你只需要提供你的域名，我就可以帮你完成统计动作</td></tr><tr><td align="left">开放模板/周期模板</td><td align="left">这类模板就相对自由，你可以自定义模板内容，变量，最终定义定时任务来定时的渲染该模板，然后选择发送等</td></tr></tbody></table><p>模板定义主要的原理就是：创建一个markdown主体内容，然后写上一些变量，最终这些变量都会被真实的值所替换。所以创建模板需要你重要的能力就是：<code>会写markdown</code>。</p><p>创建模板大致长这样：</p><p><img src="/img/ops_report/01/5.png" alt="png5"></p><h4 id="变量注册模块"><a href="#变量注册模块" class="headerlink" title="变量注册模块"></a>变量注册模块</h4><p>变量注册主要是定义你在模板中设置的变量，比如这个变量的获取方式是什么样子的，获取的数据字段是哪个。<br>对比变量的说明，主要划分了几种：<code>内置变量</code>、<code>模板变量</code>、<code>图片变量</code><br>针对这三种变量有一个简单的说明：</p><table><thead><tr><th align="left">变量类型</th><th align="left">变量说明</th><th align="left">提供信息</th></tr></thead><tbody><tr><td align="left">内置变量</td><td align="left">所有模板都可以使用的，可以理解为公共变量</td><td align="left">提供获取地址</td></tr><tr><td align="left">模板变量</td><td align="left">属于模板特有的</td><td align="left">提供获取地址</td></tr><tr><td align="left">图片变量</td><td align="left">专门下载grafana图片的</td><td align="left">提供grafana地址</td></tr></tbody></table><p>比如我举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我在模板中定义了一个变量`DATE`，那么我在变量注册的时候需要提供这些信息：</span><br><span class="line">变量获取地址：https://abc.com/var/date</span><br><span class="line">变量获取字段：data</span><br><span class="line">等到真正渲染模板动作执行的时候，就会去请求这个地址，拿到返回数据中data字段的值来具体的替换我的`DATE`数据，来达到渲染的目标。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我在模板中定义了一个变量`QPS__TREND_IMG`，这个主要是一个图片变量，获取的数据就是一个域名在某段时间的qps趋势图，那他提供的信息就是:</span><br><span class="line">grafana地址：http://grafana.c.com/****</span><br><span class="line">grafana的key：这个当然你可以放到服务端配置中去，也可以自定义，随意</span><br><span class="line">等到真正渲染模板动作执行的时候，就会去请求这个下载这个grafana图片，然后上传到你自己的存储，比如阿里云的oss，华为云的obs，最终提供一个图片地址然后替换这个变量，达到渲染的目标。</span><br></pre></td></tr></table></figure><p><img src="/img/ops_report/01/6.png" alt="png6"></p><h4 id="报告模块"><a href="#报告模块" class="headerlink" title="报告模块"></a>报告模块</h4><p>对于报告模块来讲，就是我们最终要发送和呈现的产物，那么我们可以从几个维度来讲解一下：<code>报告如何产生</code>、<code>报告产生的来源</code>、<code>报告的状态</code></p><blockquote><p>报告如何产生</p></blockquote><p>报告产生的唯一入口就是通过模板，我们可以在模板处选择对应的模板，然后创建报告，创建报告需要几个信息需要填写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 模板名称(选哪个就用哪个)</span><br><span class="line">2. 报告名称</span><br><span class="line">3. 时间范围(所有数据都依赖于时间范围，有了时间范围我们才能产生数据，然后渲染报告)</span><br></pre></td></tr></table></figure><p><img src="/img/ops_report/01/7.png" alt="png7"></p><blockquote><p>报告产生的来源</p></blockquote><p>关于报告的来源，平台的规划主要有两个，第一个是<code>手动生成的报告</code>,第二个是<code>定时任务产生的报告</code></p><blockquote><p>报告的状态</p></blockquote><p>针对报告，我们需要有几种状态：<code>未渲染</code>、<code>渲染中</code>、<code>待标注</code>、<code>已发布</code>(NotRendered、RenderedIng、ToBeLabeled、Published)</p><p><img src="/img/ops_report/01/8.png" alt="png8"></p><h4 id="数据存储模块"><a href="#数据存储模块" class="headerlink" title="数据存储模块"></a>数据存储模块</h4><p>对于数据存储模块，我们前面定义的是<code>历史数据的存储，目前监控平台会存储全量数据，这个平台只是想要存储一些特定数据或者叫做过滤后有效的数据</code>。</p><p>举个例子，当前我们平台存储的数据有哪些：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.qps峰值数据(我们监控存的是5s一个点的qps数据，不过该平台会每小时取一次时间段内的峰值qps作为存储)</span><br><span class="line">2.snat峰值数据(对于nat网关，我们也是采用类似的方式，存储过去一小时的峰值数据)</span><br><span class="line">3.带宽峰值数据</span><br><span class="line">4.弹性机器峰值数据(目前k8s集群的机器是弹性的，所以会存储每一小时的峰值数据)</span><br></pre></td></tr></table></figure><p>当我们有了这些数据，我们能做的就比较多了，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 我们基础的监控数据在获取大范围时间内的数据，都是对峰值等数据做了聚合，所以会低于真实峰值，有了每小时的峰值数据，能准确的描绘业务峰值。</span><br><span class="line">2. 当我们需要周报、月报、年报的时候，我们都可以对这些峰值数据做一些处理和分析</span><br><span class="line">3. 从一定角度上讲，我们可以分析峰值的走势，来辅助业务做一些判断，比如业务的峰值时间越来越晚，是不是说明用户睡的越来越晚呢？</span><br></pre></td></tr></table></figure><p><img src="/img/ops_report/01/9.png" alt="png9"></p><h4 id="定时任务模块"><a href="#定时任务模块" class="headerlink" title="定时任务模块"></a>定时任务模块</h4><p>定时任务，毋庸置疑，他承担着控制我们报告的发送时间和频率。比如我在平台可以针对模板创建一个定时任务：什么时间、哪个模板、发送到哪里。</p><p>目前我们使用的定时任务是对接开源的分布式定时任务框架<code>xxl-job</code>，二开了一些定时任务接口给到平台使用。</p><p>那么需要了解的主要可能有几点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.定时任务的发送地方：目前支持发送到企业微信应用、企业微信机器人</span><br><span class="line">2.定时任务的发送频率：主要取决你定时任务表达式的书写</span><br></pre></td></tr></table></figure><p><img src="/img/ops_report/01/10.png" alt="png10"></p><p><img src="/img/ops_report/01/11.png" alt="png11"></p><h3 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a>最后说一句</h3><p>对于这个平台来说，其实整体功能不难，不过个人感觉能接管不少分散的服务和脚本，也使得趋于统一化。<br>不过弊端也有，说实话当前的功能还比较单一，后续拓展有，但是还没有想好，所以对于单一的功能平台化，就是有点太卷了。</p>]]></content>
    
    
    <summary type="html">从日常巡检报告出发，我们来思考一下如何建设一个稳定性运营平台/稳定性报告平台</summary>
    
    
    
    <category term="Report" scheme="https://blog.itmonkey.icu/categories/Report/"/>
    
    
    <category term="运营报告" scheme="https://blog.itmonkey.icu/tags/%E8%BF%90%E8%90%A5%E6%8A%A5%E5%91%8A/"/>
    
    <category term="巡检" scheme="https://blog.itmonkey.icu/tags/%E5%B7%A1%E6%A3%80/"/>
    
  </entry>
  
  <entry>
    <title>上手GCP Anthos之多集群管理</title>
    <link href="https://blog.itmonkey.icu/2021/03/23/gcp-anthos-multi-cluster-mgt/"/>
    <id>https://blog.itmonkey.icu/2021/03/23/gcp-anthos-multi-cluster-mgt/</id>
    <published>2021-03-23T11:52:18.000Z</published>
    <updated>2021-03-23T15:51:56.784Z</updated>
    
    <content type="html"><![CDATA[<h3 id="提前说明"><a href="#提前说明" class="headerlink" title="提前说明"></a>提前说明</h3><p>1.上手anthos时日不多，有解释或者说明不对的地方，请指正！<br>2.细节还是比较多的，有什么问题可以直接联系我，相互讨论！</p><a id="more"></a><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p>Anthos 是一个现代应用管理平台，官方解释：<a href="https://cloud.google.com/anthos/docs/concepts/overview" target="_blank" rel="noopener">官方文档</a></p><p>对于这几天上手了解后，发现非常多功能还是很有意思和借鉴意义的。目前来说，我们主要用到了<code>多集群管理(Environ)</code>、<code>配置管理(ACM)</code>、<code>服务管理(ASM)</code>，以及其他暂时还没有用到的。</p><p><img src="/img/anthos/anthos.png" alt="png"></p><h4 id="多集群管理"><a href="#多集群管理" class="headerlink" title="多集群管理"></a>多集群管理</h4><p>字面意思理解即可，不过特别说明的是，他可以纳管其他云商k8s集群以及自建k8s集群。</p><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>我比较喜欢称它为<code>gitops</code>，一切皆文件。<br>简单描述下：你的服务部署所需要的所有yaml文件(默认在k8s里)，放在这个git里，任何改动的提交，都会同步到所有的集群(默认同步所有)，比如：证书更新管理，证书更新了，提交一下，发布到所有集群，不用一个一个去更新了(如果你有其他自动化，当我没有说)</p><p>注：这个是我比较喜欢的一个功能，很实用。</p><h4 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h4><p>对于anthos管理的工作负载，asm会管理这些服务的网格环境，提供众多功能以及istio的所有功能，可以认为是一个<code>增强改良版istio</code>。</p><p>注：当前我还没有使用上，以后使用上了，再更新一篇文章。</p><h3 id="额外提示"><a href="#额外提示" class="headerlink" title="额外提示"></a>额外提示</h3><p>初次使用anthos，gcp会提供一个900刀的试用金，可以尽情的享受了。</p><p>温馨提示：注意他的计费方式，不算太便宜。</p><h3 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h3><p>试用anthos已经两三天了，基本的模型和框架都已经搭建完毕，以及简单的测试都已经ok。大致可以分为以下几个点：</p><ul><li>注册集群</li><li>创建git中心</li><li>抽象配置文件</li><li>开启配置同步</li><li>测试批量管理</li></ul><h4 id="注册集群"><a href="#注册集群" class="headerlink" title="注册集群"></a>注册集群</h4><p>目前有两种途径来接入anthos</p><p>① 通过anthos直接创建集群(当然这个直接创建的是gke集群)<br>② 纳管现有集群 – 纳管gke集群、纳管三方集群</p><h5 id="纳管gke集群"><a href="#纳管gke集群" class="headerlink" title="纳管gke集群"></a>纳管gke集群</h5><p>我当前都是已经有现成的gke集群，所以直接选择第二种途径纳管gke集群即可。<br><img src="/img/anthos/add-new-cluster.png" alt="png1"></p><h5 id="纳管三方集群"><a href="#纳管三方集群" class="headerlink" title="纳管三方集群"></a>纳管三方集群</h5><p>可以选择添加外部集群，填写好你集群的标签，最终会生成一条注册命令，扔到你的集群中执行即可。<br><img src="/img/anthos/add-new-out-cluster.png" alt="png2"></p><h5 id="效果和验证"><a href="#效果和验证" class="headerlink" title="效果和验证"></a>效果和验证</h5><p>当你纳管好集群后，可以看看是否纳管成功以及如何判断纳管成功。</p><p>① 执行gcloud命令，查看当前纳管的集群和状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gcloud container hub memberships list</span><br><span class="line">NAME           EXTERNAL_ID</span><br><span class="line">cluster1  xxxxxx-xxxxxxxxxx-xxxxxxxxxxxx</span><br><span class="line">cluster2  xxxxxx-xxxxxxxxxx-xxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# gcloud container hub memberships describe cluster1 </span><br><span class="line">createTime: '2021-03-17T06:41:47.422321701Z'</span><br><span class="line">endpoint:</span><br><span class="line">  gkeCluster:</span><br><span class="line">    resourceLink: //container.googleapis.com/projects/******</span><br><span class="line">  kubernetesMetadata:</span><br><span class="line">    kubernetesApiServerVersion: v1.17.15-gke.800</span><br><span class="line">    memoryMb: 8282</span><br><span class="line">    nodeCount: 2</span><br><span class="line">    nodeProviderId: gce</span><br><span class="line">    updateTime: '2021-03-23T12:46:37.348171277Z'</span><br><span class="line">    vcpuCount: 8</span><br><span class="line">externalId: xxxxxx-xxxxxxxxxx-xxxxxxxxxxxx</span><br><span class="line">lastConnectionTime: '2021-03-23T12:42:31.571643848Z'</span><br><span class="line">name: projects/***********</span><br><span class="line">state:</span><br><span class="line">  code: READY</span><br><span class="line">uniqueId: xxxxxx-xxxxxxxxxx-xxxxxxxxxxxx</span><br><span class="line">updateTime: '2021-03-23T12:46:37.689233201Z'</span><br></pre></td></tr></table></figure><p>② 使用kubectl查看到底安装了什么(其实跟绝大多数集群管理平台一样，就安装了一个agent的服务，参考rancher)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kubectl get pods -n gke-connect</span><br><span class="line">NAME                                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">gke-connect-agent-20210305-01-00-54f7dcc455-l5x2f   1/1     Running   0          31h</span><br></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>集群需要有足够的资源</li><li>节点需要有拉取git的权限</li></ul><p>关于git的权限，你就简单认为他拿着你的配置文件然后做应用即可。<br>在gke中，我们需要对节点池进行配置权限：(节点池权限Cloud Source Repositories开放read only即可)<br><img src="/img/anthos/nodepool-1.png" alt="png3"><br><img src="/img/anthos/nodepool-2.png" alt="png4"></p><p>如果你是命令行创建的nodepool，可以参考这个：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud container node-pools create my-nodepool  --cluster=*** --zone ***  --num-nodes=2  --disk-size=40 --machine-type=custom-4-4096 --project *** --scopes=cloud-source-repos-ro</span><br></pre></td></tr></table></figure><p>scopes这个是权限列表，你可以按需添加，官方文档：<a href="https://cloud.google.com/sdk/gcloud/reference/container/node-pools/create#--scopes" target="_blank" rel="noopener">scopes说明</a></p><h4 id="创建git中心"><a href="#创建git中心" class="headerlink" title="创建git中心"></a>创建git中心</h4><p>顾名思义，把我们所有的配置和服务都抽象出yaml文件来，然后放到这个git里(正常anthos就是一个kubectl工具，你提交一个yaml文件，他apply一个)。<br>这个git仓库可以有很多中类型：github、gitlab、gcp仓库，这里我直接使用gcp的仓库服务，其他的你可以自己研究，还是比较简单的。</p><p><img src="/img/anthos/create-registry.png" alt="png5"></p><h4 id="抽象配置文件"><a href="#抽象配置文件" class="headerlink" title="抽象配置文件"></a>抽象配置文件</h4><p>在一步，我们首先要了解两个概念，<code>层级结构(hierarchy)</code>和<code>非结构化模式(unstructured)</code>。</p><p><code>层级结构</code>是gcp提供的一种具有约束力的文件目录结构，比如目录下有cluster和namespace两个目录，那么在这两个目录里就分别存放集群级别的配置和namespace级别的配置。<br><code>非结构化模式</code>是用户自己定义的一种文件模式，有点类似于helm、kustomize,不过值得注意的是，在这种模式下，我们每一个文件都需要标准的yaml文件。</p><h5 id="nomos"><a href="#nomos" class="headerlink" title="nomos"></a>nomos</h5><p>在整体操作之前，我们先了解一个工具<code>nomos</code>,这个工具能让我们快速创建<code>Config Sync</code>代码库，包括初始化以及语法校验。<a href="https://cloud.google.com/kubernetes-engine/docs/add-on/config-sync/how-to/nomos-command" target="_blank" rel="noopener">官方文档</a></p><p>安装一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.下载对应系统版本的二进制文件</span><br><span class="line">2.chmod +x nomos</span><br><span class="line">3.加入到环境变量中</span><br></pre></td></tr></table></figure><h5 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h5><h6 id="1-初始化层级结构目录"><a href="#1-初始化层级结构目录" class="headerlink" title="1.初始化层级结构目录"></a>1.初始化层级结构目录</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> my-repo/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nomos init</span></span><br></pre></td></tr></table></figure><p>这时候你就可以看到一个完整层级目录的结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── cluster # 集群级别的配置文件，role、rolebinding等</span><br><span class="line">├── clusterregistry # 集群注册配置文件，比如我在这里定义了集群A的标签，在下面可以使用这个标签A表示只在A集群中安装，在其他集群不安装</span><br><span class="line">├── namespaces # namespace级别的一些配置文件，如：svc、ingress、configmap、secret等</span><br><span class="line">├── README.md</span><br><span class="line">└── system</span><br><span class="line">    ├── README.md</span><br><span class="line">    └── repo.yaml</span><br></pre></td></tr></table></figure><h6 id="2-编写集群注册的文件"><a href="#2-编写集群注册的文件" class="headerlink" title="2.编写集群注册的文件"></a>2.编写集群注册的文件</h6><p>加入我们有两个集群，cluster1和cluster2，那么我们需要在<code>clusterregistry</code>这个目录加入一下文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat cluster1.yaml</span></span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: clusterregistry.k8s.io/v1alpha1</span><br><span class="line">metadata:</span><br><span class="line">  name: cluster1</span><br><span class="line">  labels:</span><br><span class="line">    cluster: cluster1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat selector-cluster1.yaml</span></span><br><span class="line">kind: ClusterSelector</span><br><span class="line">apiVersion: configmanagement.gke.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: selector-cluster1</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      cluster: cluster1</span><br></pre></td></tr></table></figure><p>上述文件表示：首先我们有一个cluster1.yaml表示我当前anthos管理的cluster1这个集群，selector-cluster1.yaml表示定义一个标签，当你满足我这个标签，就表示你选择了我这个集群。<br>这个标签就是我们后续会用到的<code>configmanagement.gke.io/cluster-selector: selector-cluster1</code>,这个需要写在我们的annotations中。</p><h6 id="3-编写namespace相关"><a href="#3-编写namespace相关" class="headerlink" title="3.编写namespace相关"></a>3.编写namespace相关</h6><p>比如我们在namespace目录下创建一个test文件夹，那么表示我所管理的集群都会创建出一个名称为test的namespace(当然前提是你没有加cluster-selector)。<br>然后你就可以在这个文件夹下创建一系列的yaml文件了，比如你的deployment、service、ingress、configmap、secret、hpa等，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll -lh <span class="built_in">test</span>/</span></span><br><span class="line">total 36K</span><br><span class="line">-rw-r--r-- 1 root root 2.9K Mar 22 15:52 deployment.yaml</span><br><span class="line">-rw-r--r-- 1 root root  359 Mar 22 15:52 image-pull-secret.yaml</span><br><span class="line">-rw-r--r-- 1 root root  276 Mar 22 15:52 hpa-cpu.yaml</span><br><span class="line">-rw-r--r-- 1 root root  461 Mar 22 15:52 ingress.yaml</span><br><span class="line">-rw-r--r-- 1 root root 9.4K Mar 22 15:52 ssl-tls.yaml</span><br><span class="line">-rw-r--r-- 1 root root  264 Mar 22 15:52 service.yaml</span><br></pre></td></tr></table></figure><p>刚刚说的集群选择标签，当前我们有两个集群cluster1和cluster2，那么假如我只想让hpa创建在cluster1怎么做呢，可以看如下配置(重点关注annotations)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat hpa-cpu.yaml</span></span><br><span class="line">apiVersion: autoscaling/v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: test-hpa</span><br><span class="line">  annotations:</span><br><span class="line">    configmanagement.gke.io/cluster-selector: cluster1</span><br><span class="line">spec:</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: extensions/v1beta1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: test-deployment</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  maxReplicas: 5</span><br><span class="line">  targetCPUUtilizationPercentage: 30</span><br></pre></td></tr></table></figure><h6 id="4-验证语法"><a href="#4-验证语法" class="headerlink" title="4.验证语法"></a>4.验证语法</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nomos vet</span></span><br></pre></td></tr></table></figure><h5 id="非结构化模式"><a href="#非结构化模式" class="headerlink" title="非结构化模式"></a>非结构化模式</h5><p>在非结构化模式中，我们采用的是helm的模式(需要对helm有一定基础，不熟悉的同学可以暂时跳过)。<br>注：他有一个特殊之处，就是我前面提到anthos只认标准的k8s yaml文件，像helm chart中的values这种他就不认，那么我们怎么去把这种应用到anthos呢？</p><p>带着问题，经过实践，我们得到如下结论：<br>① 首先我们还是需要初始化一个标准的helm chart模板 – <code>helm init</code><br>② 我们需要打包出chart包 – <code>helm package ChartName --debug</code><br>③ 生成yaml模板 – <code>helm template ChartName ChartName-Version.tgz</code><br>④ 最终复制输出的结果到一个yaml文件中，上传到git仓库中</p><p>以下是我写的最简单的一个helm Chart，为了演示作用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mychart]# tree</span><br><span class="line">.</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── templates</span><br><span class="line">│   └── namespace.yaml</span><br><span class="line">└── values.yaml</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br><span class="line"></span><br><span class="line">[root@localhost mychart]# cat values.yaml</span><br><span class="line">version: 0.0.1</span><br><span class="line">namespace: "mynamespace"</span><br><span class="line"></span><br><span class="line">[root@localhost mychart]# cat templates/namespace.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Values.namespace &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">[root@localhost]#</span><span class="bash"> helm package mychart --debug</span></span><br><span class="line">Successfully packaged chart and saved it to: /www/anthos/repohelm/mychart-0.1.0.tgz</span><br><span class="line"></span><br><span class="line"><span class="meta">[root@localhost]#</span><span class="bash"> helm template mychart mychart-0.1.0.tgz</span></span><br><span class="line">---</span><br><span class="line"><span class="meta">#</span><span class="bash"> Source: mychart/templates/namespace.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: mynamespace</span><br><span class="line"></span><br><span class="line"><span class="meta">[root@localhost]#</span><span class="bash"> 然后把输出的内容另存到一个init.yaml中，丢到git仓库里</span></span><br></pre></td></tr></table></figure><p>当然，采用非结构化模式，我们也需要校验一下语法是否正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nomos vet --<span class="built_in">source</span>-format=unstructured</span></span><br></pre></td></tr></table></figure><h4 id="开启配置同步"><a href="#开启配置同步" class="headerlink" title="开启配置同步"></a>开启配置同步</h4><p>当我们编写好以上的文件，我们就可以配置acm了。</p><h5 id="选择合适的git仓库类型"><a href="#选择合适的git仓库类型" class="headerlink" title="选择合适的git仓库类型"></a>选择合适的git仓库类型</h5><p><img src="/img/anthos/config-set-01.png" alt="png6"></p><h5 id="填写git地址等信息"><a href="#填写git地址等信息" class="headerlink" title="填写git地址等信息"></a>填写git地址等信息</h5><p>这一步填写好git地址，分支，同步间隔时间(多久从git同步一次)，源格式(层级或非结构化)<br><img src="/img/anthos/config-set-02.png" alt="png7"></p><h5 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h5><p>在这里我们也可以直接看看他到底安装了什么东西，可以从下面看出他也是类似安装了一个服务，来定时同步我们的git文件到集群中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root@localhost]#</span><span class="bash"> kubectl get pods -n config-management-system</span></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">git-importer-69699fd8b7-jzkhm   4/4     Running   1          31h</span><br><span class="line">monitor-65b649fbd4-7wvps        1/1     Running   0          34h</span><br></pre></td></tr></table></figure><h5 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h5><p>当我们安装好之后，可以从控制台查看当前的一个状态，也可以使用nomos来查看当前同步的状态：</p><p><img src="/img/anthos/config-status-03.png" alt="png8"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root@localhost]#</span><span class="bash"> nomos status</span></span><br><span class="line">Connecting to clusters...</span><br><span class="line"></span><br><span class="line">*cluster1</span><br><span class="line">  --------------------</span><br><span class="line">  &lt;root&gt;   https://source.developers.google.com/p/******@master</span><br><span class="line">  SYNCED   e160b119</span><br><span class="line"></span><br><span class="line">cluster2</span><br><span class="line">  --------------------</span><br><span class="line">  &lt;root&gt;   https://source.developers.google.com/p/******@master</span><br><span class="line">  SYNCED   e160b119</span><br></pre></td></tr></table></figure><h4 id="测试批量管理"><a href="#测试批量管理" class="headerlink" title="测试批量管理"></a>测试批量管理</h4><p>当我们一切就绪之后，可以测试下同步功能，修改任意一个文件，等待一会(取决于你配置的同步时间)，然后直接去集群中验证即可。</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>① 层级结构中，namespace目录下每一个文件夹都代表着你对应集群下的namespace，你加了这个目录则表示我要通过acm管理这个namespace了；当然没加的，但是集群又存在的，不会影响。<br>② 层级结构中，不用再写namespace.yaml这个创建namespace的文件了，默认他会读取目录名称，并创建相应的namespace。<br>③ 如果集群存在一个deployment为A，那么我创建一个deployment-A.yaml，配置名称完全跟集群中的一致，那么他不会重新创建，而是直接纳管。<br>④ 非结构化模式中也可以使用cluster-selector，你只需要在git仓库里新建一个clusterregistry目录即可，文件内容和用法跟层级结构一样。<br>⑤  …</p>]]></content>
    
    
    <summary type="html">简单介绍anthos以及一些应用场景</summary>
    
    
    
    <category term="anthos" scheme="https://blog.itmonkey.icu/categories/anthos/"/>
    
    
    <category term="gcp" scheme="https://blog.itmonkey.icu/tags/gcp/"/>
    
    <category term="gke" scheme="https://blog.itmonkey.icu/tags/gke/"/>
    
    <category term="anthos" scheme="https://blog.itmonkey.icu/tags/anthos/"/>
    
  </entry>
  
  <entry>
    <title>从零开始创建一个sre的门户网站</title>
    <link href="https://blog.itmonkey.icu/2021/03/19/sre-portal-website-start/"/>
    <id>https://blog.itmonkey.icu/2021/03/19/sre-portal-website-start/</id>
    <published>2021-03-19T07:46:57.000Z</published>
    <updated>2021-03-23T11:50:17.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>运维工具挺多，不过貌似没有一个专门的门户网站去展示展示。</p><a id="more"></a><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><ul><li>展示工具</li><li>运维通知</li><li>其他</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化一个项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@ vue-init webpack sreportal</span><br><span class="line">@ cd sreportal</span><br><span class="line">@ npm run dev</span><br></pre></td></tr></table></figure><p>安装个依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install element-plus --save</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">如何给sre做一个门户网站</summary>
    
    
    
    <category term="DevOps" scheme="https://blog.itmonkey.icu/categories/DevOps/"/>
    
    
    <category term="运维门户" scheme="https://blog.itmonkey.icu/tags/%E8%BF%90%E7%BB%B4%E9%97%A8%E6%88%B7/"/>
    
    <category term="vue" scheme="https://blog.itmonkey.icu/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>如何梳理我负责的业务(SRE)</title>
    <link href="https://blog.itmonkey.icu/2021/03/19/how-to-comb-my-business/"/>
    <id>https://blog.itmonkey.icu/2021/03/19/how-to-comb-my-business/</id>
    <published>2021-03-19T06:18:35.000Z</published>
    <updated>2021-03-19T06:26:01.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>业务一多，我们就需要针对性的梳理负责的业务，不能一个业务一个样子。有效的梳理业务能带来以下好处：</p><a id="more"></a><p>1.更加深入了解业务<br>2.能从不同的业务中抽象出相同规则，做一些标准化自动化工作<br>3.业务之间运维工作可以有参考<br>4.业务故障能帮助快速定位问题点<br>5.让ab岗，轮值更进一步</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>当你梳理了业务文档，以下点是需要你注意的：<br>1.定期/及时更新业务文档<br>2.要覆盖全面，不仅包含业务文档，也要有运维所做的配套设置(告警、监控、cicd等)<br>3.有一个总表记录业务变更</p><h3 id="梳理条目"><a href="#梳理条目" class="headerlink" title="梳理条目"></a>梳理条目</h3><p>那一个业务，我们需要梳理哪些基础的信息呢？</p><ul><li>基础平台信息</li><li>业务部署架构</li><li>后端资源信息</li><li>CI/CD</li><li>监控、日志、告警、自动化</li><li>灾备、预案信息</li><li>变更记录</li><li>日常问题排查记录</li><li>优化</li><li>总结</li><li>注意事项</li></ul><h3 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h3><table><thead><tr><th align="left">梳理条目</th><th align="left">梳理细节</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">基础平台信息</td><td align="left">部署在哪里<br>如果是新环境，我怎么进入环境<br>平台的权限相关备注<br>如果是新平台，基础环境要备注好，vpc、子网、nat等</td><td align="left"></td></tr><tr><td align="left">业务部署架构</td><td align="left">一个架构图还是要的<br>服务有哪些，服务名称、服务作用、资源占用<br>域名有哪些、以及解析地址<br>cdn配置等</td><td align="left"></td></tr><tr><td align="left">后端资源信息</td><td align="left">实例列表<br>实例规格<br>资源同步相关文档</td><td align="left"></td></tr><tr><td align="left">CI/CD</td><td align="left">cicd流程用什么<br>是否有自建cicd工具</td><td align="left"></td></tr><tr><td align="left">监控、日志、告警、自动化</td><td align="left">监控地址(基础监控，业务监控)<br>日志地址<br>告警发送人、告警发送规则<br>其他自动化配置</td><td align="left"></td></tr><tr><td align="left">灾备、预案信息</td><td align="left">灾备文档梳理<br>预案文档梳理<br>日常演练记录<br>压测文档记录</td><td align="left"></td></tr><tr><td align="left">变更记录</td><td align="left">业务侧：业务变更、人员变更<br>运维侧：配置变更、支撑变更</td><td align="left"></td></tr><tr><td align="left">日常问题排查记录</td><td align="left">故障记录<br>日常问题记录</td><td align="left"></td></tr><tr><td align="left">优化</td><td align="left">性能优化<br>支撑优化(支撑工具开发等)<br>成本优化</td><td align="left"></td></tr><tr><td align="left">总结</td><td align="left">稳定性运营周报<br>月报<br>年报<br>重要节日报</td><td align="left"></td></tr><tr><td align="left">注意事项</td><td align="left">证书更新<br>特殊配置</td><td align="left"></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">如何有效和规范的梳理我所负责的业务</summary>
    
    
    
    <category term="运维进阶" scheme="https://blog.itmonkey.icu/categories/%E8%BF%90%E7%BB%B4%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="运维" scheme="https://blog.itmonkey.icu/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="梳理" scheme="https://blog.itmonkey.icu/tags/%E6%A2%B3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>关于前端自动刷新cdn相关想法</title>
    <link href="https://blog.itmonkey.icu/2021/03/08/auto-refresh-cdn/"/>
    <id>https://blog.itmonkey.icu/2021/03/08/auto-refresh-cdn/</id>
    <published>2021-03-08T07:43:37.000Z</published>
    <updated>2021-03-08T09:20:44.982Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当前我司的前端构建+部署架构是：jenkins或者gitlabci—容器平台。</p><p>正常我们刷新cdn的流程是jenkins构建完代码后，在容器平台进行新版本发布，新版本发布成功后，手动刷新cdn。这样的操作会比较繁琐。</p><a id="more"></a><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>针对上述背景，我们期望达到的目的就是版本发布完成后，自动刷新cdn，不需要手动介入。</p><p>当前现状有两个方面：</p><ul><li>jenkins构建完成之后，容器平台会自动发布该版本</li><li>jenkins构建完成之后，需要手动到容器平台发布该版本</li></ul><p>所以针对上述所有的情况，我的想法就是：<br>1.jenkins构建完成之后，创建一个刷新任务，这个任务包含哪个服务，要刷新什么，刷新状态等<br>2.写一个定时任务，去实时监听是否有未刷新的任务<br>3.如果获取到未刷新的任务，去监听这个任务对应服务的发布状态<br>4.如果服务发布状态为已经发布，那么就可以触发刷新cdn动作了</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="1-创建一个任务平台"><a href="#1-创建一个任务平台" class="headerlink" title="1.创建一个任务平台"></a>1.创建一个任务平台</h4><p>这个平台需要实现如下接口：<br>1.新增任务<br>2.修改任务状态<br>3.根据id查询任务详情<br>4.获取所有任务列表</p><p>具体的就差不多这些吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GIN-debug] POST   /api/v1/cdnr/task         --&gt; whyme-api/controller/cdn.AddRefreshTask (4 handlers)</span><br><span class="line">[GIN-debug] GET    /api/v1/cdnr/alltask      --&gt; whyme-api/controller/cdn.GetTaskList (4 handlers)</span><br><span class="line">[GIN-debug] GET    /api/v1/cdnr/tasks        --&gt; whyme-api/controller/cdn.GetUnCompletedTask (4 handlers)</span><br><span class="line">[GIN-debug] GET    /api/v1/cdnr/task/:taskid --&gt; whyme-api/controller/cdn.GetRefreshTaskStatus (4 handlers)</span><br><span class="line">[GIN-debug] PUT    /api/v1/cdnr/task/:taskid/:status --&gt; whyme-api/controller/cdn.UpdateRefreshTaskStatus (4 handlers)</span><br></pre></td></tr></table></figure><p>关于任务字段的设计：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">taskid 任务id</span><br><span class="line">namespace 项目名称</span><br><span class="line">service 服务名称</span><br><span class="line">version 本次发布的服务版本</span><br><span class="line">url 要刷新的地址</span><br><span class="line">createtime 创建时间</span><br><span class="line">updatetime 更新时间</span><br><span class="line">status 0代表未刷新，1代表刷新了</span><br></pre></td></tr></table></figure><p>如果你的刷新量级比较大或者有更高的要求，你可以上kafka，像我们就很简单，直接接mysql。</p><h4 id="2-写一个定时任务"><a href="#2-写一个定时任务" class="headerlink" title="2.写一个定时任务"></a>2.写一个定时任务</h4><p>这个定时的复杂度取决于你上述任务字段设计的逻辑，像我上述涉及的，那这个定时任务会比较复杂点：<br>1.实现未刷新任务查询<br>2.实现服务发布状态获取<br>3.实现修改刷新任务<br>4.实现刷新cdn</p><p>如果你把这些状态<code>status</code>细分一下，就可以用多个定时任务分别去修改和获取，所以还是看你复杂度，如果复杂就分开，简单写在一起也没关系。</p><p>最终定时任务执行后差不多就是这个流程吧：<br><img src="/img/cdn-auto-refresh/1.png" alt="png1"></p><h4 id="3-加一个友好的前端界面"><a href="#3-加一个友好的前端界面" class="headerlink" title="3.加一个友好的前端界面"></a>3.加一个友好的前端界面</h4><p>写一个页面去展示你的刷新任务状态<br><img src="/img/cdn-auto-refresh/2.png" alt="png2"></p><h4 id="4-加一个友好的通知机制"><a href="#4-加一个友好的通知机制" class="headerlink" title="4.加一个友好的通知机制"></a>4.加一个友好的通知机制</h4><p>目前当有刷新任务完成刷新，会通知出来，不论你是用钉钉，企业微信还是邮件，自己写就完事了</p><p><img src="/img/cdn-auto-refresh/3.png" alt="png3"></p><h3 id="开源想法"><a href="#开源想法" class="headerlink" title="开源想法"></a>开源想法</h3><p>代码都很简单，开源不开源没啥必要。。真的！</p><p>想法和逻辑有了，那还不是很快就写完了</p>]]></content>
    
    
    <summary type="html">讨论下前端发布后，cdn如何自动刷新的相关内容</summary>
    
    
    
    <category term="DevOps" scheme="https://blog.itmonkey.icu/categories/DevOps/"/>
    
    
    <category term="cdn" scheme="https://blog.itmonkey.icu/tags/cdn/"/>
    
  </entry>
  
  <entry>
    <title>定义ingress 403页面</title>
    <link href="https://blog.itmonkey.icu/2021/02/02/ingress-self-define-403/"/>
    <id>https://blog.itmonkey.icu/2021/02/02/ingress-self-define-403/</id>
    <published>2021-02-02T05:43:39.000Z</published>
    <updated>2021-02-02T07:16:08.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>默认的ingress controller提供的403 error页面太丑了，想要定制化一下</p><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>1.增加一个configmap，定义403页面<br>2.挂载到ingress-controller的pod里<br>3.对单个ingress对象增加annotation注解</p><h3 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h3><h4 id="增加一个configmap"><a href="#增加一个configmap" class="headerlink" title="增加一个configmap"></a>增加一个configmap</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">meitu403.html: | </span><br><span class="line">   &lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;/head&gt;</span><br><span class="line">   &lt;html&gt;</span><br><span class="line">       &lt;h1 align="center"&gt;禁止外部访问&lt;/h1&gt;</span><br><span class="line">       &lt;p align="center"&gt;请连接美图wifi或者有线!&lt;/p&gt;</span><br><span class="line">   &lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="挂载到ingress-controller的pod里"><a href="#挂载到ingress-controller的pod里" class="headerlink" title="挂载到ingress-controller的pod里"></a>挂载到ingress-controller的pod里</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volumeMounts:</span><br><span class="line">        - mountPath: /etc/nginx/conf</span><br><span class="line">          name: nginx-whitelist-volume</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">      - configMap:</span><br><span class="line">          defaultMode: 420</span><br><span class="line">          name: nginx-whitelist</span><br><span class="line">        name: nginx-whitelist-volume</span><br></pre></td></tr></table></figure><h4 id="增加annotation"><a href="#增加annotation" class="headerlink" title="增加annotation"></a>增加annotation</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/server-snippet: error_page 403 /meitu403.html; location  /meitu403.html &#123; internal; root /etc/nginx/conf; allow all; &#125;</span><br></pre></td></tr></table></figure><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="/img/ingress-self-define-403/1.png" alt="png1"></p>]]></content>
    
    
    <summary type="html">如何自定义ingress 403页面</summary>
    
    
    
    <category term="k8s" scheme="https://blog.itmonkey.icu/categories/k8s/"/>
    
    
    <category term="ingress" scheme="https://blog.itmonkey.icu/tags/ingress/"/>
    
  </entry>
  
</feed>
